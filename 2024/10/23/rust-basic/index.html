<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Rust Basic | Marnie Wu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="入门 Getting StartedRust静态类型语言（statically typed）：在编译时就确定了所有表达式的类型 强类型语言（strongly typed）：一切皆需要明确的类型声明  rustc：rust 编译器（compiler）  检查 rust 是否安装成功：rustup --version 将某个 rust 文件编译成二进制（binary）文件：rustc &lt;file">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust Basic">
<meta property="og:url" content="https://marniewu.github.io/2024/10/23/rust-basic/index.html">
<meta property="og:site_name" content="Marnie Wu">
<meta property="og:description" content="入门 Getting StartedRust静态类型语言（statically typed）：在编译时就确定了所有表达式的类型 强类型语言（strongly typed）：一切皆需要明确的类型声明  rustc：rust 编译器（compiler）  检查 rust 是否安装成功：rustup --version 将某个 rust 文件编译成二进制（binary）文件：rustc &lt;file">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241010155641561.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241013075143718.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241005203754332.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241010163617345.png">
<meta property="article:published_time" content="2024-10-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-10T17:17:59.934Z">
<meta property="article:author" content="Marnie Wu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marniewu.github.io/images/image-20241010155641561.png">
  
    <link rel="alternate" href="/atom.xml" title="Marnie Wu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Marnie Wu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://marniewu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-rust-basic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/23/rust-basic/" class="article-date">
  <time class="dt-published" datetime="2024-10-22T16:00:00.000Z" itemprop="datePublished">2024-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Rust Basic
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="入门-Getting-Started"><a href="#入门-Getting-Started" class="headerlink" title="入门 Getting Started"></a>入门 Getting Started</h2><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>静态类型语言（statically typed）：在编译时就确定了所有表达式的类型</p>
<p>强类型语言（strongly typed）：一切皆需要明确的类型声明</p>
<ul>
<li><p>rustc：rust 编译器（compiler）</p>
<ul>
<li>检查 rust 是否安装成功：<code>rustup --version</code></li>
<li>将某个 rust 文件编译成二进制（binary）文件：<code>rustc &lt;file_name&gt;.rs</code></li>
</ul>
</li>
<li><p>rustup：rust 安装器和版本管理工具</p>
<ul>
<li><code>rustup update</code> 升级 rust</li>
<li><code>rustup doc</code> 打开本地 rust 文档</li>
</ul>
</li>
<li><p>命名规则（naming rule）：蛇形式（snake_case）</p>
</li>
<li><p>语句（statement）：一定要加分号（semicolon），表示执行某个操作但没有返回值的某个指令</p>
<ul>
<li>表达式语句：以分号结尾的表达式</li>
<li>声明语句</li>
</ul>
</li>
<li><p>表达式（expression）：主要用于计算求值（expression-base language）</p>
</li>
</ul>
<h3 id="Crate"><a href="#Crate" class="headerlink" title="Crate"></a>Crate</h3><p>用 rust 写的库或者可执行程序 a rust library or executable program</p>
<p>crate.io - rust 官方包注册表</p>
<h3 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h3><p>rust 包管理器 rust package manager</p>
<ul>
<li>支持管理项目依赖 <code>cargo update</code></li>
<li>支持编译、运行项目 <code>cargo build, cargo run</code></li>
<li>支持上传 crates.io <code>cargo publish</code></li>
<li>Cargo.toml：dependencies declaration file</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup a new project dir</span></span><br><span class="line">cargo new &lt;project_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile project [debug or release version]</span></span><br><span class="line">cargo build [--release]</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile project and execute [debug or release version]</span></span><br><span class="line">cargo run [--release]</span><br><span class="line"></span><br><span class="line"><span class="comment">// update all dependencies (keep semi-version 0.8.5 -&gt; 0.8.latest)</span></span><br><span class="line">cargo update</span><br></pre></td></tr></table></figure>

<h2 id="通用概念-Common-Concepts"><a href="#通用概念-Common-Concepts" class="headerlink" title="通用概念 Common Concepts"></a>通用概念 Common Concepts</h2><h3 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h3><p>默认都是不可变变量（immutable variables），不用声明类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>声明可变变量（mutable variables），在运行时才会确定变量的值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">x = <span class="number">6</span>; <span class="comment">// 若这句不运行，则 x 值还是 5</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<h3 id="作用域规则-Scoping-Rules"><a href="#作用域规则-Scoping-Rules" class="headerlink" title="作用域规则 Scoping Rules"></a>作用域规则 Scoping Rules</h3><p>作用域是一个变量在程序中的有效范围，从变量声明的点开始知道当前作用域的结束就是一个有效范围。</p>
<p>作用域范围一般分为 函数作用域、代码块作用域。</p>
<p>不可变变量、可变变量、常量都是遵循这个作用域规则</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">foo_global_variable</span> :<span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// the start of the block</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo_local_variable</span> :<span class="type">i32</span> = <span class="number">2</span>; <span class="comment">// defined in current block, only can access in current block</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of foo_global_variable is: &#123;&#125;&quot;</span>, foo_global_variable); <span class="comment">// ✅ access anywhere within foo_block</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of foo_local_variable is: &#123;&#125;&quot;</span>, foo_local_variable);</span><br><span class="line">  &#125; <span class="comment">// the end of the block</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The value of foo_local_variable is: &#123;&#125;&quot;</span>, foo_local_variable); <span class="comment">// ❌ outer of the block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遮蔽-Shadowing"><a href="#遮蔽-Shadowing" class="headerlink" title="遮蔽 Shadowing"></a>遮蔽 Shadowing</h3><p>let 不可变变量支持重定义（遮蔽 shadowing）：虽然是不可变变量，但是可以用过去的值重新赋值，且可更改类型（与 <code>mut</code> 的不同之处）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>块内遮蔽（shadowing）也遵循作用域规则，块内重定义变量的操作结果对外是屏蔽的，在块外访问到的还是原值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the start of the block</span></span><br><span class="line">       <span class="comment">// 遮蔽（shadowing）</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x); <span class="comment">// ✅ The value of x is: 2</span></span><br><span class="line">    &#125; <span class="comment">// the end of the block</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x); <span class="comment">// ✅ The value of x is: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量-Constants"><a href="#常量-Constants" class="headerlink" title="常量 Constants"></a>常量 Constants</h3><p>声明常量必须要带类型（data types）注释（annotation），在编译时期就确定了变量的值，命名规范大写蛇形式（UPPER_SNAKE_CASE）</p>
<p>编译后是直接替换值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u32: unsigned 32-bit integer 无符号32位整数</span></span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, THREE_HOURS_IN_SECONDS); <span class="comment">// 🎯 编译后：println!(&quot;&#123;&#125;&quot;, 60 * 60 * 3)</span></span><br></pre></td></tr></table></figure>

<h3 id="静态变量-Static"><a href="#静态变量-Static" class="headerlink" title="静态变量 Static"></a>静态变量 Static</h3><p>特点如上同常量</p>
<p>作用域（scope）：在整个程序中共享，可以再多个线程之间共享 —— 即 全局变量！！</p>
<p>编译后是指向引用地址</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> A : <span class="type">i32</span> = <span class="number">1</span>; <span class="comment">// 假设这个 static 变量分配的内存地址为 0x123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, A); <span class="comment">// 🎯 编译后：存在对 A 的引用，指向 A 的内存地址</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型 Data Types"></a>数据类型 Data Types</h3><h4 id="原始类型-Primitive-Types"><a href="#原始类型-Primitive-Types" class="headerlink" title="原始类型 Primitive Types"></a>原始类型 Primitive Types</h4><h5 id="整数型-Integer-Types"><a href="#整数型-Integer-Types" class="headerlink" title="整数型 Integer Types"></a>整数型 Integer Types</h5><p>默认 <code>i32</code></p>
<p>如果可能是负数则用 <code>i[bit]</code>，反之用 <code>u[bit]</code>，位数由运行代码的电脑决定</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 二进制位数和[整/负]数大小范围的关系</span></span><br></pre></td></tr></table></figure>

<h5 id="浮点数型-Floating-Point-Types"><a href="#浮点数型-Floating-Point-Types" class="headerlink" title="浮点数型 Floating-Point Types"></a>浮点数型 Floating-Point Types</h5><p>默认 <code>f64</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br></pre></td></tr></table></figure>

<h5 id="布尔型-The-Boolean-Types"><a href="#布尔型-The-Boolean-Types" class="headerlink" title="布尔型 The Boolean Types"></a>布尔型 The Boolean Types</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// both are 👌🏻</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h5 id="文本类型-Textual-Types"><a href="#文本类型-Textual-Types" class="headerlink" title="文本类型 Textual Types"></a>文本类型 Textual Types</h5><p><code>char</code> 字符型</p>
<p><code>unicode</code> 编码，1 char &#x3D; 4 bytes，默认单引号包裹的文字（单个文字）表示字符型变量，也可以显式声明类型,</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="复合类型-Compound-Types"><a href="#复合类型-Compound-Types" class="headerlink" title="复合类型 Compound Types"></a>复合类型 Compound Types</h4><p>🕵🏻‍♂️ ：下面字符串类型建议看完所有权部分知识，再去理解比较好！！</p>
<h5 id="Character-encoding-format"><a href="#Character-encoding-format" class="headerlink" title="Character encoding format"></a>Character encoding format</h5><ul>
<li>ASCII：1 character &#x3D; 7 bits binary，total 128 characters（max decimal number of 7-bit binary number）</li>
<li>UTF-8：1 character &#x3D; 1～4 bytes &#x3D; (1～4) x 8 bits，total 1,112,064 character</li>
</ul>
<h4 id="🎯-TODO：Memory-management-ownership-in-Rust"><a href="#🎯-TODO：Memory-management-ownership-in-Rust" class="headerlink" title="🎯 TODO：Memory management &amp; ownership in Rust"></a>🎯 TODO：Memory management &amp; ownership in Rust</h4><p><img src="/images/image-20241010155641561.png" alt="image-20241010155641561"></p>
<p><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/memory-management-rust-amit-nadiger#:~:text=The%20.,string%20literals%20and%20other%20constants">https://www.linkedin.com/pulse/memory-management-rust-amit-nadiger#:~:text=The%20.,string%20literals%20and%20other%20constants</a>.</p>
<p>【TODO】compile binary –&gt; read-only memory 是什么？</p>
<p>【TODO】Machine words 是什么？</p>
<p>【TODO】Rc smart pointer  reference counted pointer</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=rDoqT-a6UFg&t=118s">Visualizing memory layout of Rust’s data types</a></p>
<h5 id="String-文本字符串型"><a href="#String-文本字符串型" class="headerlink" title="String 文本字符串型"></a><code>String</code> 文本字符串型</h5><p>一串动态长度的 UTF-8 编码序列，用来表示文本字符串。UTF-8 编码规则用 1～4 个字节表示一个字符，是默认拥有所有权的类型。</p>
<p>动态分配大小所以存储在 heap 上，对应栈上的变量存储指针（ptr &#x3D; 内存地址）、长度（len &#x3D; 实际长度）、容量（capacity &#x3D; 可用长度）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 类型值内置了修改和其他的各种方法</span></span><br><span class="line"><span class="comment">// mutable variable</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// modify string s</span></span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="comment">// replace first character of string s</span></span><br><span class="line">s.<span class="title function_ invoke__">replace_range</span>(<span class="number">0</span>..<span class="number">1</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line"><span class="comment">// check the result</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);  <span class="comment">// ✅ 输出：s = Hello!</span></span><br></pre></td></tr></table></figure>

<h5 id="String-Slice-文本字符串切片类型"><a href="#String-Slice-文本字符串切片类型" class="headerlink" title="String Slice 文本字符串切片类型"></a><code>String Slice</code> 文本字符串切片类型</h5><p>我们把某个字符串的某段字符串称为 slice（字符串切片&#x2F;字符串片段）。上面提到的，文本字符串本身是动态长度的 UTF-8 编码序列，且拥有数据的所有权。当我们只需要借用字符串文本数据本身时，我们需要使用 <code>&amp;str</code> 类型，它包含指针（ptr &#x3D; 该 slice 第一个字符在内存中对应的地址）、长度（len &#x3D; 从第一个字符开始，一共多少个字符），slice 因为是借用关系，本身是不可变的。字符串本身是动态大小的类型，有了 slice 的借用类型之后，编译时就可以计算出对应字符串所占字节大小，这对 Rust 这种强静态编译语言是必需的。它有两种具体使用场景：</p>
<ol>
<li>普通文本字符串（string literal）：不可修改</li>
<li>作为某个 <code>String</code> 类型的切片字符串：不可修改</li>
</ol>
<p>可以看到，都是不可修改，所以当我们有要修改字符串的计划，我们就应该使用上面 <code>String</code> 类型，而不修改的话就选择 <code>&amp;str</code> 类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">str_and_string</span>() &#123;</span><br><span class="line">    <span class="comment">// 普通文本字符串 string literals</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">normal_str</span> = <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line">    <span class="comment">// 可操作的、拥有所有权的 String 类型字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutable_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(normal_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a string slice of String, 没有修改字符串的计划</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;mutable_string[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello = &#123;&#125;&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改字符串 &amp;mut 才能修改</span></span><br><span class="line">    <span class="title function_ invoke__">do_some_mutation</span>(&amp;<span class="keyword">mut</span> mutable_string);</span><br><span class="line">    <span class="comment">// 只需要借用字符串的值</span></span><br><span class="line">    <span class="title function_ invoke__">only_use_text</span>(&amp;mutable_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mutable_string = &#123;&#125;&quot;</span>, mutable_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_some_mutation</span>(input: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    input.<span class="title function_ invoke__">replace_range</span>(<span class="number">0</span>..<span class="number">1</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">    input.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;add this to the end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">only_use_text</span>(input: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;input[..=<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;greet = &#123;&#125;&quot;</span>, [hello, world].<span class="title function_ invoke__">concat</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>隐式类型转换 <code>String</code> -&gt; <code>&amp;str</code></p>
<p>当函数参数定义为 <code>&amp;str</code> 切片类型时，我们在传入的是完整切片时是可以直接传入 <code>String</code> 类型字符串的，相当于 <code>&amp;s[..]</code>，Rust 实现了自动解引用，在必要时会将 <code>&amp;String</code> 自动转换成 <code>&amp;str</code> 。这样使得，如果接受参数是字符串的引用，我们采用 <code>&amp;str</code> 作为入参，但能获得两种类型数据的兼容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> :<span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line"><span class="comment">// String 转换成 slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = s.<span class="title function_ invoke__">as_str</span>();</span><br></pre></td></tr></table></figure>

<p>注意：反过来是不行的，因为 <code>String</code> 类型 转 切片类型，没有转换成本，而从 切片类型 转 <code>String</code> 类型还需要为其重新申请内存，对性能是有损耗的，Rust 不会自动做这个行为。</p>
<h5 id="与其他类型的转换"><a href="#与其他类型的转换" class="headerlink" title="与其他类型的转换"></a>与其他类型的转换</h5><p><img src="/images/image-20241013075143718.png" alt="image-20241013075143718"></p>
<h5 id="元组-The-Tuple-Type"><a href="#元组-The-Tuple-Type" class="headerlink" title="元组 The Tuple Type"></a>元组 The Tuple Type</h5><p>混合类型 —— 多种类型的数值的集合，一旦定义了不能改变长度</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值(1)</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>); <span class="comment">// ✅ The value of y is: 6.4</span></span><br><span class="line"><span class="comment">// 取值(2)</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Values in tup: &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>); <span class="comment">// ✅ Values in tup: 500 6.4 1</span></span><br></pre></td></tr></table></figure>

<h5 id="数组-The-Array-Type"><a href="#数组-The-Array-Type" class="headerlink" title="数组 The Array Type"></a>数组 The Array Type</h5><p>数组的定义其实就是为分配一段连续的相同数据类型的内存块。</p>
<p><code>[T; N]</code> 表示 <code>N</code> 个值的数组，每个值的类型为 <code>T</code>。数组长度一经定义不可修改，所以编译时数组占用的内存大小就已是确定的了，不能追加或删除元素，但可以修改元素的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明类型和长度，后赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 定义后无法再修改大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的值，可以简化创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// 5 个 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转迭代器，得到 (index, value) 枚举对 list</span></span><br><span class="line">a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>()</span><br></pre></td></tr></table></figure>

<p>遍历方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知长度</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未知长度：迭代器</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的引用都是值的传递，即和原数组没有联系，原数组不受任何影响</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_arr</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = a;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a &#123;:?&#125;&quot;</span>, a); <span class="comment">// [0, 20]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b &#123;:?&#125;&quot;</span>, b); <span class="comment">// [10, 20]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1111 &#123;:?&#125;&quot;</span>, arr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 参数传递，是直接复制 arr 的值传入，和 arr 无关</span></span><br><span class="line">    <span class="title function_ invoke__">update</span>(arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;2222 &#123;:?&#125;&quot;</span>, arr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update</span>(<span class="keyword">mut</span> arr: [<span class="type">i32</span>; <span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            arr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;update &#123;:?&#125;&quot;</span>, arr); <span class="comment">// [0, 0, 0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="向量-The-Vec-Type"><a href="#向量-The-Vec-Type" class="headerlink" title="向量 The Vec Type"></a>向量 The Vec Type</h5><p>An array-like data structure，一种类数组数据结构，和数组的区别是它支持动态大小，即可以增加或删除元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      使用Vec和HashMap实现书籍库管理系统</span></span><br><span class="line"><span class="comment">      添加书籍，查询库存，更新库存，删除书籍</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">books</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="string">&quot;The Rust Programming Language&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Welcome to Rust&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Rust by Example&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BookSystem</span> &#123;</span><br><span class="line">        map: HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">BookSystem</span> &#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(books: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> BookSystem &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">book</span> <span class="keyword">in</span> books &#123;</span><br><span class="line">                map.<span class="title function_ invoke__">insert</span>(book.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BookSystem &#123; map &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加书籍</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.map.<span class="title function_ invoke__">insert</span>(name.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询库存</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">find</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.map.<span class="title function_ invoke__">get</span>(&amp;name.<span class="title function_ invoke__">to_string</span>()) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(num) =&gt; *num,</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="number">0</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新库存</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">update</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>, num: <span class="type">i32</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.map.<span class="title function_ invoke__">insert</span>(name.<span class="title function_ invoke__">to_string</span>(), num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除书籍</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">delete</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.map.<span class="title function_ invoke__">remove_entry</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">log</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; Current stock &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (k, v) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.map &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;[&#123;&#125;]: &#123;&#125;&quot;</span>, k, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sys</span> = BookSystem::<span class="title function_ invoke__">new</span>(books);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book_name</span> = <span class="string">&quot;Easy Rust&quot;</span>;</span><br><span class="line">    sys.<span class="title function_ invoke__">add</span>(book_name);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">    sys.<span class="title function_ invoke__">update</span>(book_name, <span class="number">3</span>);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The stock of [&#123;&#125;] is &#123;&#125;&quot;</span>, book_name, sys.<span class="title function_ invoke__">find</span>(book_name));</span><br><span class="line">    sys.<span class="title function_ invoke__">delete</span>(book_name);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="切片-The-Slice-Type"><a href="#切片-The-Slice-Type" class="headerlink" title="切片 The Slice Type"></a>切片 The Slice Type</h5><p>表示 <code>String</code> 类型、<code>Array</code> 类型、<code>Vec</code> 类型 的局部数据，<code>&amp;T</code> 只引用值，<code>&amp;mut T</code> 可以修改原数据</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">切片常用函数</span><br><span class="line"><span class="bullet">-</span> len(): 取 slice 元素个数</span><br><span class="line"><span class="bullet">-</span> is<span class="emphasis">_empty(): 判断 slice 是否为空</span></span><br><span class="line"><span class="emphasis">- contains(): 判断是否包含某个元素</span></span><br><span class="line"><span class="emphasis">- repeat(): 重复 slice 指定次数</span></span><br><span class="line"><span class="emphasis">- reverse(): 反转 slice</span></span><br><span class="line"><span class="emphasis">- join(): 将各元素压平（flatten）并通过指定的分隔符连接起来</span></span><br><span class="line"><span class="emphasis">- swap(): 交换两个索引处的元素，如 s.swap(1, 3)</span></span><br><span class="line"><span class="emphasis">- windows(): 以指定大小的窗口进行滚动迭代</span></span><br><span class="line"><span class="emphasis">- start_</span>with(): 判断 slice 是否以某个 slice 开头</span><br></pre></td></tr></table></figure>

<h5 id="自定义类型-Custom-Types"><a href="#自定义类型-Custom-Types" class="headerlink" title="自定义类型 Custom Types"></a>自定义类型 Custom Types</h5><p>Rust 自定义数据类型主要通过 <code>struct</code> 和 <code>enum</code> 关键字形成</p>
<ul>
<li><code>struct</code>: 定义一个结构体型数据</li>
<li><code>enum</code>: 定义一个枚举型数据</li>
</ul>
<h6 id="结构体-Structures"><a href="#结构体-Structures" class="headerlink" title="结构体 Structures"></a>结构体 Structures</h6><p>基础用法，结构体可以定义 n 多个字段</p>
<ul>
<li>结构体变量和一般变量一样，默认也是不可变的（immutable），<code>let mut T = struct XXX</code> 定义可变的（mutable）结构体变量</li>
<li>可以没有任何字段名，但不能没有字段类型，这种结构体长的像元组，所以被被称为元祖结构体（tuple struct），例如：<code>struct Point(i32, i32, i32)</code> 表示一个点的坐标 <code>x,y,z</code></li>
<li>可以不包含任何字段，即没有类型也没有名称，被称为单元结构体</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">me</span> = Person &#123; name: <span class="string">&quot;Marnie&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A unit struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A tuple struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>(<span class="type">i32</span>, <span class="type">f32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Pair</span>(<span class="number">8</span>, <span class="number">0.2</span>);</span><br><span class="line"><span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct with two fields</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0.5</span>, y: <span class="number">1.2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Structs can be reused as fields of another struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// A rectangle can be specified by where the top left and bottom right</span></span><br><span class="line">    <span class="comment">// corners are in space.</span></span><br><span class="line">    top_left: Point,</span><br><span class="line">    bottom_right: Point,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point_top_left</span> = Point &#123; x: <span class="number">0.5</span>, y: <span class="number">1.2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point_bottom_right</span> = Point &#123; x: <span class="number">1.8</span>, y: <span class="number">0.2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123; top_left: point_top_left, bottom_right: point_bottom_right &#125;;</span><br></pre></td></tr></table></figure>

<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>结构体更新语法：我们可以用 <code>..structA</code> 给 <code>structB</code> 进行更新，在 <code>structB</code> 中没有显示声明的字段，都会从 <code>structA</code> 中取 。</p>
<p>但是注意了📢，在 Rust 中严格管控着数据所有权（ownership），所以当针对没有 copy 特性的字段被用来赋值之后，该字段的数据所有权即会发生转移。只要有一个字段发生了所有权变化，那么整个结构体就已经是不完整的了，该结构体本身就不能再被转移，即无法整个结构体直接使用。</p>
<p>没有 copy 特性（trait）指的就是那些存在 heap 上的数据，在 stack-side 存储的是其内存块的 pointer，赋值操作即原指针失效，内存地址转移到新指针上。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">     active: <span class="literal">true</span>,</span><br><span class="line">     username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;example1&quot;</span>),</span><br><span class="line">     email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;example1@examples.com&quot;</span>),</span><br><span class="line">     sign_in_count: <span class="number">1</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">     email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;example2@examples.com&quot;</span>),</span><br><span class="line">     ..user1</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>结构体可以包含行为，即带有方法（方法和函数是有区别的）的结构体</p>
<h6 id="枚举型-Enum"><a href="#枚举型-Enum" class="headerlink" title="枚举型 Enum"></a>枚举型 Enum</h6><p>结构体通常是描述带有不同字段的某个类型，而枚举型指的是某个更上层的类型下会包含多个不同类型，比如动物类型包含猫猫、狗狗、兔子、猪等等</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  Dog,</span><br><span class="line">  Cat,</span><br><span class="line">  Rabbit,</span><br><span class="line">  Pig,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a>函数 Functions</h3><h4 id="语句-Statements"><a href="#语句-Statements" class="headerlink" title="语句 Statements"></a>语句 Statements</h4><p>表示一个要执行的操作，没有返回值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="comment">// ❌ 首先 let y = 1; 是个语句，没有返回值，且（）中加表达式只能在 if、while 条件判断下使用</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等同于 let x = 1; let y = 1;</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制-Control-Flow"><a href="#流程控制-Control-Flow" class="headerlink" title="流程控制 Control Flow"></a>流程控制 Control Flow</h3><h4 id="条件控制-if"><a href="#条件控制-if" class="headerlink" title="条件控制 if"></a>条件控制 <code>if</code></h4><p><code>if</code> 表达式的条件（condition）必须是 <code>bool</code> 类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ error[E0308]: mismatched types, expected `bool`, found integer&quot;</span></span><br><span class="line"><span class="keyword">if</span> number &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Never print: expected `bool`, found integer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if or else</code> 表达式后紧跟的代码块被称为 arms，和 <code>match</code> 表达式的 arms 一致</p>
<p><code>if</code> 表达式的代码块最后一行若是表达式，即为当前块的返回值</p>
<p>若是多个 <code>if...else if</code> 每个代码块的返回值类型需要一致</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">if_else_expressions</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">55</span>;</span><br><span class="line">    <span class="keyword">const</span> NOT_MATCHED_MESSAGE: &amp;<span class="type">str</span> = <span class="string">&quot;Not Matched&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="string">&quot;Divide by 4&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="string">&quot;Divide by 3&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="string">&quot;Divide by 2&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NOT_MATCHED_MESSAGE</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> message != NOT_MATCHED_MESSAGE &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>todo()!</code> 表示延迟实现当前代码块，和占位符概念类似，即可以跳过类型检查</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="title function_ invoke__">todo</span>()!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环-Loop"><a href="#循环-Loop" class="headerlink" title="循环 Loop"></a>循环 Loop</h4><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a><code>loop</code></h4><p><code>loop</code> 加大括号声明循环（代码块可以有返回值），<code>continue</code> 跳出本次循环，<code>break</code> 跳出并终止整个循环，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">loop_expressions</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">10</span>; <span class="comment">// 终止循环，并有返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套循环，用 <code>单引号 + label</code> 的格式命名，<code>break LOOP_NAME</code> 跳出对应循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">nested_loops</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, count);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;&#125;&quot;</span>, remaining);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 结束并跳出当前循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>; <span class="comment">// 结束并跳出 &#x27;counting_up 循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while"><a href="#while" class="headerlink" title="while"></a><code>while</code></h4><p>如果需要判断某些条件的循环，可以使用 <code>while</code> 更方便</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">while_case</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> count &lt; <span class="number">12</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h4><p><code>for loop</code> 遍历数组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loop in array</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">for_loop</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;i=&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1..=5 快速创建一个1-5的</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;n=&#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// (1..=5).rev() 快速创建一个5-1倒序的数组</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> (<span class="number">1</span>..=<span class="number">5</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;n=&#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop in vector</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">vector_case</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示并非所有权转移，&amp; 表示借用，借用是只读</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vv</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        <span class="comment">// vv 是对 v 中的某个 vector 的引用，</span></span><br><span class="line">        <span class="comment">// 引用的本质是一个指针，指针不能直接和值进行比较，</span></span><br><span class="line">        <span class="comment">// 需要加 *号 解引用，解引用就表示该引用变量的值</span></span><br><span class="line">        <span class="keyword">if</span> *vv == <span class="number">1</span> &#123;</span><br><span class="line">            *vv = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v=&#123;&#125;&quot;</span>, vv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="所有权-Ownership"><a href="#所有权-Ownership" class="headerlink" title="所有权 Ownership"></a>所有权 Ownership</h3><p>所有权是控制一个 Rust 程序如何管理内存的一套规则。所有程序都要有管理它们在运行时使用计算机内存的方式。</p>
<h4 id="内存管理方式-Memory-Management"><a href="#内存管理方式-Memory-Management" class="headerlink" title="内存管理方式 Memory Management"></a>内存管理方式 Memory Management</h4><p>常见的内存管理方式：</p>
<ul>
<li>垃圾回收（Garbage Collection）：如 JavaScript、Java 这种动态语言，语言层面设计了一套内存回收机制，垃圾回收器会持续追踪内存的分配并定期找到不再被使用的内存进行释放回收，让开发者无需去关心内存的分配和回收</li>
<li>手动管理（Manual Management）：如 C、C++ 这种静态语言，需要手动调用分配和释放内存的方法进行操作，这让开发者需要对内存的分配及释放负责，忘记释放会导致内存浪费，太早释放又会导致获得无效的变量</li>
</ul>
<p>第三种 —— Rust 使用的内存管理方式：所有权系统（Ownership System）</p>
<ul>
<li>所有者（ower）指的是这块内存（memory）是属于谁的，包括访问和修改的能力</li>
<li>每个值都有一个所有者，任何时候都只能有一个有效所有者</li>
<li>当所有者离开作用域（scope），值会被丢弃（drop）</li>
<li>遵循所有权系统规则，编译器在编译时通过静态分析管理内存安全，违背规则的程序不会通过编译</li>
<li>通过借用（borrowing，即引用）机制来共享数据</li>
</ul>
<h4 id="🎯-TODO：内存分配方式-Memory-Allocation"><a href="#🎯-TODO：内存分配方式-Memory-Allocation" class="headerlink" title="🎯 TODO：内存分配方式 Memory Allocation"></a>🎯 TODO：内存分配方式 Memory Allocation</h4><ul>
<li>栈（Stack）：连续的内存空间，从低地址到高地址逐步分配，简单数据类型会被直接存储在栈上，便于操作</li>
<li>堆（Heap）：非连续内存空间，申请多少大小空间就一次性分配多少，会通过一个指针指向这一块内存空间，复杂数据类型的值会在堆上开辟对应的空间存放，而栈上对应的这个变量存的是与这块内存相关的指针信息，即内存地址（adress）、大小（Capacity）、长度（Length）</li>
<li>Static：blahblahblah…</li>
</ul>
<h4 id="转移-或-复制-Move-or-Copy"><a href="#转移-或-复制-Move-or-Copy" class="headerlink" title="转移 或 复制 Move or Copy"></a>转移 或 复制 Move or Copy</h4><p>基于不同的内存分配方式，针对数据和变量之间的赋值操作，在 Rust 中也会有两种表现情况：</p>
<ul>
<li>简单数据类型：一般是固定大小的数据，值存放在栈上，赋值是对值的拷贝（copy）</li>
<li>复杂数据类型：一般为非固定大小数据，值被存放在堆上，该内存一旦分配，赋值的操作默认被看做为转移（move），即将该内存的所有权转移给某个变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a; <span class="comment">// directly copy 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// move</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a; <span class="comment">// move the ownership of &quot;Hello&quot; from a to b</span></span><br><span class="line"><span class="comment">// current, a is considered as transferred, which means it&#x27;s no longer needed</span></span><br></pre></td></tr></table></figure>

<p>其实可以简单理解，转移（move）是所有权（ownership）系统实现 “内存所有者只能有一个” 的一种规则机制，这个机制防止出现数据竞争的可能 —— 多个线程对统一资源进行访问和修改，从而导致程序结果与期望不符。本身具有所有权的变量本质是存在栈上的某个指针类型变量，它的作用是为了指向堆中的某块内存，所以一经转移，相当于指针不再指向这块内存，这个变量就不再有效了，即不可以再被访问。</p>
<h4 id="所有权和生命周期（Lifetimes）"><a href="#所有权和生命周期（Lifetimes）" class="headerlink" title="所有权和生命周期（Lifetimes）"></a>所有权和生命周期（Lifetimes）</h4><p>所有权是指某块内存的所有者，所有者是某个变量，而变量的生命周期和所在作用域相关，在某个作用域下定义的变量只能在该作用域下使用。所有权也有着相应的限制，变量在某个作用域（scope）内被分配到对应数据的内存，在离开作用域后，变量会变得无效，它会交还对某个数据内存的所有权，则该“无主”的数据内存会被视为不再需要的，会触发自动释放内存的机制，也就是回收内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// s is valid from this point</span></span><br><span class="line">  <span class="comment">// s is the owner of the string &quot;Hello&quot;</span></span><br><span class="line">&#125; <span class="comment">// this scope is over now, s and string &quot;Hello&quot; are not valid</span></span><br><span class="line"><span class="comment">// the data is not valid means it is no longer needed, which will trigger the step of freeing memory</span></span><br></pre></td></tr></table></figure>

<p>当变量被传入某个函数，也是发生了转移操作，意味着数据的所有权被传递给了函数，函数外已经没有权利访问和修改该变量所指的数据。如下例子：</p>
<p><img src="/images/image-20241005203754332.png" alt="image-20241005203754332"></p>
<p>第一步，<code>s</code> 拥有了 <code>string &quot;Hello&quot;</code> 的所有权</p>
<p>第二步，将 <code>string &quot;Hello&quot;</code> 的所有权转移给了 <code>carry_params</code> 函数</p>
<p>而 <code>carry_params</code> 没有对参数 <code>s</code> 做任何处理，那么在函数执行完毕后，离开作用域，入参 <code>s</code> 对应也不再有效，对应占用的数据内存会被释放</p>
<p>第三步，我们再打印 <code>s</code> 就会得到值已被转移了，即无权访问的编译错误提示</p>
<h4 id="拥有所有权的作用"><a href="#拥有所有权的作用" class="headerlink" title="拥有所有权的作用"></a>拥有所有权的作用</h4><p>所有权是指对某块内存的所有，即拥有读写这块内存的权力，当我们需要修改某个数据时，我们就需要拥有其所有权，才能有修改的能力。而当我们只需要读，而不需要写，那就不必拥有或者转移其所有权。可以看到，有了所有权规则的加持，代码变得更加安全但也因此增加了书写代码的难度。</p>
<p>上面提到如果我们不需要获得某个数据的所有权，只是想要访问值，可以用另一个概念 —— 借用（borrow）。</p>
<h4 id="借用-Borrow"><a href="#借用-Borrow" class="headerlink" title="借用 Borrow"></a>借用 Borrow</h4><p>当我们不需要数据的所有权时，我们使用借用来访问数据的值，借用分为两种：</p>
<ul>
<li>borrow：不可变的借用，我只是把数据借给你用 <code>&amp;T</code></li>
<li>borrow mutably：可变的借用，我不仅把数据借给你用，且给你修改它的权限 <code>&amp;mut T</code>，这种借用也可以被叫做引用（reference）</li>
</ul>
<p>其实可以理解为，<code>&amp;</code> 给了读数据的权力，<code>&amp;mut</code>  在读的基础上给了写的权力，但数据（也就是这块内存）的拥有者并没有变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">str_and_string</span>() &#123;</span><br><span class="line">    <span class="comment">// 普通文本字符串 string literals</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">normal_str</span> = <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line">    <span class="comment">// 可操作的、拥有所有权的 String 类型字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutable_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(normal_str);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// a string slice of String,</span></span><br><span class="line">    <span class="comment">// 借用（引用） &quot;hello, &quot;，没有修改字符串的需求</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;mutable_string[..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;slice = &#123;&#125;&quot;</span>, slice);</span><br><span class="line">    <span class="comment">// 借用对象 和 被借用对象 都是指向同一块内存，所以相等</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice, mutable_string);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1️⃣ 默认借用，只需要借用字符串的值，不涉及所有权</span></span><br><span class="line">    <span class="title function_ invoke__">only_use_text</span>(&amp;mutable_string);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2️⃣ 可变的借用，不仅可以访问值，还给了修改值的权力</span></span><br><span class="line">   <span class="comment">// 需要声明 &amp;mut 才能修改字符串</span></span><br><span class="line">    <span class="title function_ invoke__">do_some_mutation</span>(&amp;<span class="keyword">mut</span> mutable_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mutable_string = &#123;&#125;&quot;</span>, mutable_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_some_mutation</span>(input: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    input.<span class="title function_ invoke__">replace_range</span>(<span class="number">0</span>..<span class="number">1</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">    input.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;add this to the end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">only_use_text</span>(input: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;input[..=<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;greet = &#123;&#125;&quot;</span>, [hello, world].<span class="title function_ invoke__">concat</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="🎯-TODO：生命周期-Lifetimes"><a href="#🎯-TODO：生命周期-Lifetimes" class="headerlink" title="🎯 TODO：生命周期 Lifetimes"></a>🎯 TODO：生命周期 Lifetimes</h3><h5 id="NLL-——-Non-Lexical-Lifetimes"><a href="#NLL-——-Non-Lexical-Lifetimes" class="headerlink" title="NLL —— Non-Lexical Lifetimes"></a>NLL —— Non-Lexical Lifetimes</h5><h5 id="Dangling-Referencing-悬垂引用"><a href="#Dangling-Referencing-悬垂引用" class="headerlink" title="Dangling Referencing 悬垂引用"></a>Dangling Referencing 悬垂引用</h5><p>指的是一个变量是有效状态的时间，即可以被使用的时长，通常也被叫做存活（live）时间。</p>
<p>生命周期是 Rust 用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围，确保在引用仍然有效的时候使用它们。</p>
<p>在 Rust 中，一个变量的存活时间与其作用域（scope）和是否还存在被使用（引用 references）有关。</p>
<ul>
<li><p>作用域规则决定了一个变量能否被访问，在某个作用域下定义的变量也只在这个作用域内有效，即离开作用域后无法被访问，会自动被销毁。</p>
</li>
<li><p>当编译器检查到一个变量不再存在任何被引用被借用关系后，该变量也会被自动销毁。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> :<span class="type">i32</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 存在被使用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x); <span class="comment">// after this line, x has no more references, will be automatically destroyed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> :<span class="type">i32</span> = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h4 id="借用规则-Borrow-Rules"><a href="#借用规则-Borrow-Rules" class="headerlink" title="借用规则 Borrow Rules"></a>借用规则 Borrow Rules</h4><ul>
<li>一个变量只能存在一个可变引用或者多个不可变引用，不能同时存在可变和不可变引用</li>
</ul>
<h4 id="借用检查器-Borrow-Checker"><a href="#借用检查器-Borrow-Checker" class="headerlink" title="借用检查器 Borrow Checker"></a>借用检查器 Borrow Checker</h4><p>前面说了，借用是用于不关心所有权的场景下的，那没有所有权就意味着我需要依赖被我借用的那个变量，当它不合法时、无效时，那我的借用行为也是不可能通过的。Borrow Checker 便是在编译时，检查借用是否合法，即被借用的变量是否还在有效的生命周期内。结合前面提到的所有权的生命周期，来看下截图上的例子：</p>
<p><img src="/images/image-20241010163617345.png" alt="image-20241010163617345"></p>
<p>可以看到报错部分说的是被借用值 x 存活的不够长，重点看下黄色框内，模拟画的作用域结构图。</p>
<ul>
<li><code>r</code> 在 a 作用域中创建，即它存活在作用域 a 存活的期间，即 foo 函数执行期间</li>
<li><code>x</code> 在 b 作用域中创建，即它存活在作用域 b 存活的期间，作用域 b 是个 block 作用域，在它执行完成后内部变量都会自动释放，即 <code>x</code> 在作用域 b 外无效</li>
</ul>
<p>因为 <code>r</code> 是个借用类型，Borrow Checker 会检查被借用变量是否是有效的，当发现被借用变量的生命周期小于借用变量的生命周期，即 <code>x</code> 的生命周期小于 <code>r</code> 的生命周期，这是不合法的 —— 报错。所以如果是存在借用关系的两个变量，那么被借用变量的存活时间一定要比借用变量存活的时间更长，存活时间更长可以归纳为两种情况：</p>
<ul>
<li>相同作用域范围下，被借用变量定义早于借用变量</li>
<li>借用变量的作用域层级深于被借用变量（越深销毁越早）</li>
</ul>
<h5 id="📸-TODO-手动管理可能会遇到的问题"><a href="#📸-TODO-手动管理可能会遇到的问题" class="headerlink" title="📸 TODO 手动管理可能会遇到的问题"></a>📸 TODO 手动管理可能会遇到的问题</h5><p>内存泄露</p>
<p>悬空指针</p>
<p>缓冲区溢出</p>
<h2 id="泛型（Generics）和特质（Traits）"><a href="#泛型（Generics）和特质（Traits）" class="headerlink" title="泛型（Generics）和特质（Traits）"></a>泛型（Generics）和特质（Traits）</h2><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `unwrap()`: 有值的时候会取值，没值的时候会 `panic`</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = s.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p1);</span><br></pre></td></tr></table></figure>

<h2 id="返回值与错误处理"><a href="#返回值与错误处理" class="headerlink" title="返回值与错误处理"></a>返回值与错误处理</h2><h3 id="可恢复的错误-Result"><a href="#可恢复的错误-Result" class="headerlink" title="可恢复的错误 Result&lt;T, E&gt;"></a>可恢复的错误 <code>Result&lt;T, E&gt;</code></h3><p>从系统全局角度来看是可以接受的错误，这些错误只会影响某个用户自身的操作进程，一般是逻辑层面上的错误（业务逻辑、操作逻辑），不会对系统的全局稳定性产生影响。</p>
<h4 id="使用-Result-返回值"><a href="#使用-Result-返回值" class="headerlink" title="使用 Result 返回值"></a>使用 Result 返回值</h4><h3 id="不可恢复的错误-panic"><a href="#不可恢复的错误-panic" class="headerlink" title="不可恢复的错误 panic!"></a>不可恢复的错误 <code>panic!</code></h3><p>全局性或者系统性的错误，列入数组越界访问、影响启动流程的错误等等，这些错误是影响系统流程的。</p>
<h4 id="主动触发-panic"><a href="#主动触发-panic" class="headerlink" title="主动触发 panic"></a>主动触发 panic</h4><p>Rust 提供了 <code>panic!</code> 宏，当调用执行该宏时，程序会打印出一个错误信息，展开报错点前面的函数调用堆栈，最后退出程序。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="backtrace-栈展开"><a href="#backtrace-栈展开" class="headerlink" title="backtrace 栈展开"></a>backtrace 栈展开</h4><p>默认程序执行调用栈输出是开启 <code>--debug</code> 的时候才会展示，可以通过 <code>RUST_BACKTRACE=1 cargo run</code> 来手动开启调用栈回溯。</p>
<p>栈展开也称栈回溯，包含了函数调用的顺序，按照逆序排列：最近调用的函数在列表最上方。</p>
<h4 id="unwrap-方法"><a href="#unwrap-方法" class="headerlink" title="unwrap 方法"></a><code>unwrap</code> 方法</h4><ul>
<li><code>Option</code> : 有值的时候会取值，没值的时候会调用 <code>panic!</code></li>
<li><code>Result</code> : <code>Ok</code> 会返回 <code>Ok</code> 中的值，<code>Err</code> 会为我们调用 <code>panic!</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">first</span>(&amp;arr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is &#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<h4 id="expect-方法"><a href="#expect-方法" class="headerlink" title="expect 方法"></a><code>expect</code> 方法</h4><p>用于设置预期的 panic 错误文案</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, file);</span><br></pre></td></tr></table></figure>

<h4 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h4><p><code>unwrap</code> 方法在遇到错误情况下都会直接调用 <code>panic!</code> 从而会直接终止程序的进行，但很多情况下我们遇到的都是预期内的错误情况，并不需要终止，只需要将错误向上传播，这时我们就不用使用 <code>unwrap</code> 方法。取而代之，通常使用 <code>?</code> 链式调用传播错误，它的功能是问号前的表达式执行结果成功则继续向后执行，若结果失败或者说错误，则截停执行逻辑到当前表达式为止并将错误返回，此时如果前一个表达式设置了错误 callback 等类似的处理，就能触发相应的逻辑。</p>
<h5 id="Option-和-Result-的互转"><a href="#Option-和-Result-的互转" class="headerlink" title="Option 和 Result 的互转"></a>Option 和 Result 的互转</h5><p>Result 有两个结果 <code>Ok</code> 和 <code>Err</code>，Option 包含 <code>Some</code> 和 <code>None</code></p>
<ul>
<li><p>Result 转 Option，转换即将 <code>ok</code> 和 <code>err</code> 都转为 <code>Some</code></p>
<ul>
<li><p><code>err(): Err -&gt; Some</code></p>
</li>
<li><p><code>ok(): Ok -&gt; Some</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">err</span>();</span><br><span class="line"><span class="keyword">if</span> f.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;no file&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">ok</span>();</span><br><span class="line"><span class="keyword">if</span> f.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;no file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Option 转 Result</p>
<ul>
<li><code>ok_or()</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marniewu.github.io/2024/10/23/rust-basic/" data-id="cm3bv7en70002ha166pn217qi" data-title="Rust Basic" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/10/24/smart-pointers/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Smart Pointers
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/01/first-project/">First Project</a>
          </li>
        
          <li>
            <a href="/2024/10/24/smart-pointers/">Smart Pointers</a>
          </li>
        
          <li>
            <a href="/2024/10/23/rust-basic/">Rust Basic</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Marnie Wu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>