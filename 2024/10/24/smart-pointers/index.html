<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Smart Pointers | Marnie Wu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="智能指针 Smart Pointers首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。 在 Rust 中最常见的指针就是引用（reference），引用变量向被它引用的变量借用（borrow）它指向的数据，这意味着它们自身是没有对该数据的所有权（ownership）的。 引用只包含一个指向被引用变量的指针，除此之外，引">
<meta property="og:type" content="article">
<meta property="og:title" content="Smart Pointers">
<meta property="og:url" content="https://marniewu.github.io/2024/10/24/smart-pointers/index.html">
<meta property="og:site_name" content="Marnie Wu">
<meta property="og:description" content="智能指针 Smart Pointers首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。 在 Rust 中最常见的指针就是引用（reference），引用变量向被它引用的变量借用（borrow）它指向的数据，这意味着它们自身是没有对该数据的所有权（ownership）的。 引用只包含一个指向被引用变量的指针，除此之外，引">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241031162223186.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241107133927309.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241108213447782.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241108224953665.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241108233250046.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241109000000451.png">
<meta property="og:image" content="https://marniewu.github.io/images/image-20241109131227963.png">
<meta property="og:image" content="https://marniewu.github.io/images/smart-pointers/home_work_2.png">
<meta property="og:image" content="https://marniewu.github.io/images/smart-pointers/home_work_2_result.png">
<meta property="article:published_time" content="2024-10-24T07:41:13.000Z">
<meta property="article:modified_time" content="2024-12-01T20:34:05.606Z">
<meta property="article:author" content="Marnie Wu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marniewu.github.io/images/image-20241031162223186.png">
  
    <link rel="alternate" href="/atom.xml" title="Marnie Wu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Marnie Wu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://marniewu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-smart-pointers" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/24/smart-pointers/" class="article-date">
  <time class="dt-published" datetime="2024-10-24T07:41:13.000Z" itemprop="datePublished">2024-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Smart Pointers
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="智能指针-Smart-Pointers"><a href="#智能指针-Smart-Pointers" class="headerlink" title="智能指针 Smart Pointers"></a>智能指针 Smart Pointers</h2><p>首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。</p>
<p>在 Rust 中最常见的指针就是引用（reference），引用变量向被它引用的变量借用（borrow）它指向的数据，这意味着它们自身是没有对该数据的所有权（ownership）的。</p>
<p>引用只包含一个指向被引用变量的指针，除此之外，引用就再无其他功能了。而 Rust 是静态编译语言，在编译期间就需要确定变量数据的大小以及何时释放。所以设计了智能指针，在普通指针的基础上，还包含了当前长度（len）、最大长度（capacity）等字段，这些都是用来确定指针类型指向的那块数据所需的内存 size 的字段。像是我们之前用过的 <code>String</code> 、<code>Vec</code> 都是智能指针数据类型。</p>
<p>不同于普通指针，智能指针是具有所有权的指针，且实现了 Deref（解引用）和 Drop（清理）两个 trait（特征），这使得他们可以像指针一样解引用并在离开作用域是自动清理资源。这是对智能指针是什么的一个大致概括，具体功能可以通过后面更多的实际例子去理解更为自然。</p>
<h3 id="为什么存在智能指针？"><a href="#为什么存在智能指针？" class="headerlink" title="为什么存在智能指针？"></a>为什么存在智能指针？</h3><h4 id="性能管理-—-处理大体量的数据"><a href="#性能管理-—-处理大体量的数据" class="headerlink" title="性能管理 — 处理大体量的数据"></a>性能管理 — 处理大体量的数据</h4><p>栈是我们用于快速读写的内存空间，并不适合存储过大的数据。相对来说，简单的数据类型会被分配在栈上，但针对简单却大体量数据，我们就不应该再继续存储在栈上了，栈溢出会引起程序的崩溃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">大体量数据，长度为 1_000_000 的数组，数组默认是分配的栈内存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr_stack</span> = [<span class="number">0</span>; <span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> arr_stack &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，我们会得到如下报错：</p>
<p><img src="/images/image-20241031162223186.png" alt="image-20241031162223186"></p>
<p>正如前面所说 —— 栈溢出，程序中止运行了。</p>
<h4 id="处理更复杂的数据结构"><a href="#处理更复杂的数据结构" class="headerlink" title="处理更复杂的数据结构"></a>处理更复杂的数据结构</h4><p>Rust 是静态编译语言，这意味着它在编译时期就是需要知道每个数据所需内存大小，而针对一些复杂的数据结构，如递归结构、分享结构【❓TODO 这是啥】等，是没有固定大小的，而智能指针就是为了解决这一问题设计的。</p>
<p>举个例子，常规 <code>enum</code> ，因为一次只会使用 <code>enum</code> 的某一个值，所以该 <code>enum</code> 的所需内存大小取决于其下面内存占用最大的一个枚举值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  Quit,</span><br><span class="line">  Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">  <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum Message 中所需内存最大的是 ChangeColor，</span></span><br><span class="line"><span class="comment">// 则该 enum 所需内存为 ChangeColor 所需的内存大小</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Message::Quit;</span><br></pre></td></tr></table></figure>

<p>更复杂的数据结构，递归 <code>enum</code> 类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List), <span class="comment">// 动态大小，无法确定 size</span></span><br><span class="line">  Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于递归 <code>enum</code> 来说，基于我们前面计算 <code>enum</code> 大小的方式，会发现我们并不能知道哪个是内存大小最大的枚举值，递归的枚举值是动态的，所以我们无法得出递归类型的数据大小。</p>
<h4 id="【TODO】在普通指针基础上，完善更多的功能"><a href="#【TODO】在普通指针基础上，完善更多的功能" class="headerlink" title="【TODO】在普通指针基础上，完善更多的功能"></a>【TODO】在普通指针基础上，完善更多的功能</h4><p>❓TODO：所有权、悬垂指针、动态大小？</p>
<h4 id="【TODO】RC-智能指针"><a href="#【TODO】RC-智能指针" class="headerlink" title="【TODO】RC 智能指针"></a>【TODO】RC 智能指针</h4><p>智能指针是 Rust 确保其安全性的一种方式。智能指针是一种包裹了数据和提供了一些额外功能的数据结构，例如所有权（ownership）和引用计数（reference counting）。Rust 设计了多种智能指针的数据类型，适用于多种不同的场景。</p>
<h3 id="Box-Smart-Pointer"><a href="#Box-Smart-Pointer" class="headerlink" title="Box Smart Pointer"></a>Box Smart Pointer</h3><p>Box 智能指针是 Rust 中智能指针的一种，它是在栈上拥有固定大小的指针，但其指向的数据，在堆上可以是任意大小的数据。所以当我们使用了 Box 智能指针，我们是可以在编译时就知道所需内存大小的。因此上面说到的编译时无法计算内存大小的问题，便就迎刃而解了。</p>
<p>我们将改写上面递归 <code>enum</code> 的例子，用 Box 智能指针来解决问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将递归嵌套的 List 类型改写成 Box&lt;List&gt; 智能指针类型</span></span><br><span class="line"><span class="comment">// 智能指针在栈侧是拥有固定大小的指针，可以顺利通过编译</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">  Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123; Cons, Nil &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// Box::new() 创建 Box 智能指针类型变量</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>智能指针之所以功能强大，还因为 Rust 为其实现了两种特征（trait），Deref Trait 和 Drop Trait，让我们一起了解下。</p>
<h3 id="The-Deref-Trait"><a href="#The-Deref-Trait" class="headerlink" title="The Deref Trait"></a>The Deref Trait</h3><p>Deref Trait 解引用是为了让智能指针能像普通指针一样使用而实现的特征（trait）。这句话有两个关键点：</p>
<ol>
<li><p>什么是 trait（特征）？</p>
</li>
<li><p>什么叫像普通指针一样使用？</p>
</li>
</ol>
<p>我们逐一了解一下：）</p>
<h4 id="Traits-特征"><a href="#Traits-特征" class="headerlink" title="Traits 特征"></a>Traits 特征</h4><p> 特征（traits）是 Rust 设计出可以让不同类型拥有相同行为（behavior）的一种实现，在描述某种或者说某类行为时可以包含1个或者多个方法（methods），即特征就是我们用来使得不同类型能够共享（sharing）同一批方法的手段。</p>
<p>我们看一下 trait 的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">TraitA</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">method_A</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">method_B</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般我们描述 trait 时，会包含一个或多个方法的签名，如果对方法写了具体实现，则作为该方法的默认行为。我们也可以在具体类型上重写（overwrite）特征下的方法，来自定义不同类型上的实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StructA</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// once impl A for B means B is shared with all methods in A</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TraitA</span> <span class="keyword">for</span> <span class="title class_">StructA</span> &#123;</span><br><span class="line">    <span class="comment">// overwrite method_A of trait TraitA</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method_a</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>([<span class="string">&quot;I&#x27;m&quot;</span>, &amp;<span class="keyword">self</span>.name].<span class="title function_ invoke__">join</span>(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = StructA &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;aaa&quot;</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// call the methods of trait</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">name</span> = a.<span class="title function_ invoke__">method_a</span>();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, name);</span><br><span class="line">  </span><br><span class="line">  a.<span class="title function_ invoke__">method_b</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 定义很多内置的特征，并为我们提供了 <code>derive</code> 属性，用于在一个 struct 或 enum 上生成对某个 trait 的实现的相关代码，这里的代码就是将该 trait 所拥有的默认实现复制过来。这样我们就能快速的拥有一个 trait 的所有默认行为，内置的特征需要通过 <code>use xxx</code> 导入之后使用。</p>
<h4 id="像普通指针一样使用"><a href="#像普通指针一样使用" class="headerlink" title="像普通指针一样使用"></a>像普通指针一样使用</h4><p>其实指的就是，可以对于指针变量使用 <code>*</code> 操作符，我们知道因为所有权的关系，我们只能对指针类型的变量进行借用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// &amp;String</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, x, y, x == y); <span class="comment">// ❌ [ERROR] can&#x27;t compare `String` with `&amp;String`.</span></span><br></pre></td></tr></table></figure>

<p>这里编译会报错，因为第 3 行无法将不同类型的两个值进行比较，x 是 String 类型，而 y 是 a reference to String。</p>
<p>y 就是借用了 x，借用就意味着其实就只是拿到了一个内存地址，那么当我们需要直接使用数据时（如：上面做比较的场景 x &#x3D;&#x3D; y）就需要用 <code>*</code> 操作符做解引用，拿到内存地址对应的数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// &amp;String</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, x, y, x == *y); <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>*</code> 操作符实现了 deref，还有包括我们经常使用的 <code>.</code> 操作符，是默认带有解引用功能的，通过例子看一下：</p>
<p><img src="/images/image-20241107133927309.png" alt="image-20241107133927309"></p>
<p>可以看到，当我们在使用 <code>.</code> 操作符时，会得到自动解引用之后的结果（倒数第 2 行），并且最后一行我们看到，无论是多加了多少层的引用，都能得到最终指向的那块数据。这就是 <code>.</code> 操作符上带有的魔法之一 —— 自动解引用。</p>
<p>为了更好的理解解引用特征，我们手动还原一个自己的 <code>MyBox</code> 智能指针类型。</p>
<h4 id="手动还原-Box-智能指针"><a href="#手动还原-Box-智能指针" class="headerlink" title="手动还原 Box 智能指针"></a>手动还原 Box 智能指针</h4><p>首先，<code>MyBox</code> 是一个结构体，它只有一个字段 —— 被他包裹的类型，且不需要字段名，即我们采用<strong>元组结构体</strong>（tuple struct）构造 <code>MyBox</code>。这里还需要使用泛型 <code>T</code>，被包裹的类型是由调用的时候传入的。</p>
<blockquote>
<p>这一部分需要补充泛型（generics）的内容，可以参考 <a target="_blank" rel="noopener" href="https://course.rs/basic/trait/generic.html">https://course.rs/basic/trait/generic.html</a></p>
</blockquote>
<p>使用泛型的规范是，先声明 <code>xxx&lt;T&gt;</code> 后使用 <code>structNameXXX(T)、functionNameXXX(x: T)</code> 等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br></pre></td></tr></table></figure>

<p>接着实现 <code>new</code> 方法，在 Rust 中使用 <code>impl</code> 来定义方法，如 <code>impl Circle</code> ，泛型用 <code>impl&lt;T&gt; Circle&lt;T&gt;</code> 。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，在 <code>MyBox</code> 上实现 <code>deref trait</code> ，可以参考官网 <code>Deref Trait</code> 给出的示例实现：</p>
<p><img src="/images/image-20241108213447782.png" alt="image-20241108213447782"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123; <span class="comment">// Target 就是目标类型 T</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span> <span class="comment">// 因为 MyBox 是元组结构体，对应的值 self.0</span></span><br><span class="line">    &#125;  <span class="comment">// 注意：解引用并不会涉及所有权转移，返回的值还是一个引用值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以在 MyBox 类型变量上使用解引用功能了，让我们试下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Marnie&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Marnie&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, a, *n, a == *n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20241108224953665.png" alt="image-20241108224953665"></p>
<p>以上就是模拟 MyBox 并实现 Deref Trait 的大致过程，当我们使用 <code>*v</code> 时，就会去 <code>v</code> 对应的类型 <code>T</code> 上找 <code>deref</code> 方法，即 <code>*(v.deref())</code>，所以但凡是实现了 <code>Deref Trait</code> 的类型变量都可以使用 <code>*</code> 操作符来解引用。</p>
<p>在官网关于”使用 Deref Trait 将智能指针像常规引用一样对待”有很详细的介绍，细节可以更多的参考 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait</a>，这里再提一点比较重要的内容：</p>
<h4 id="Implicit-Deref-Coerions-隐式的强制解引用"><a href="#Implicit-Deref-Coerions-隐式的强制解引用" class="headerlink" title="Implicit Deref Coerions 隐式的强制解引用"></a>Implicit Deref Coerions 隐式的强制解引用</h4><p>在 Deref Trait 相关内容下，有一个知识点叫 Deref coerion 强制解引用，意思是在某些场景下，Rust 会自动发生解引用。</p>
<p>这里会发生自动解引用的场景是在变量作为参数传入方法 methods 或者函数 functions 时，若传入变量类型实现了 Deref Trait，变会发生自动解引用的行为。我们分析看下官方的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里写了一个 <code>hello</code> 函数，接收 string slice 类型的参数，如果我们继续用前面 <code>MyBox</code> 的实例 <code>n</code> 传入 <code>hello</code> 函数 <code>hello(&amp;n)</code>，如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Marnie&quot;</span>)); <span class="comment">// MyBox&lt;String&gt;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;n); <span class="comment">// 🤔...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现，编辑器并没有提示任何编译错误，这里就是强制解引用的作用。</p>
<p>首先，我们传入的 <code>n</code> 本身是个 <code>MyBox&lt;String&gt;</code> 类型，按照强制解引用的发生规则 —— 当我们将某个类型作为参数传入函数或者方法时，会自动发生解引用。<code>MyBox</code>类型的解引用实现我们前面已经还原了，那么这一步强制解引用就相当于调用 <code>n.deref()</code>，则 <code>&amp;n</code> 从 <code>&amp;MyBox&lt;String&gt;</code> -&gt; <code>&amp;String</code>，这么看起来还是不对呀，目标参数接收的是 <code>String Slice</code>，现在还只是 <code>String</code>。好，这里注意 📢，当类型上实现了 Deref Trait 的话强制解引用会一直继续自动发生，即可能发生连续的解引用。</p>
<p>我们上一步强制解引用得到的是类型 <code>String</code>，在标准库里 <code>String</code> 也对应实现了 <code>Deref Trait</code> ，所以会再次做强制解引用，我们可以查看官网看到标准库中对于 <code>String</code> 上 <code>Deref Trait</code> 实现的签名描述：</p>
<p><img src="/images/image-20241108233250046.png" alt="image-20241108233250046"></p>
<p>可以看到 <code>String</code> 的 <code>deref</code> 方法返回 <code>string slice</code> 类型，所以才满足了 <code>hello</code> 函数，并不会有编译问题。</p>
<p>关于这个连续强制解引用，我尝试再用一些自定义的类型例子来验证一下是否如此：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeA</span>(<span class="type">i32</span>); <span class="comment">// i32</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeB</span>(TypeA); <span class="comment">// TypeA</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeC</span>(TypeB); <span class="comment">// TypeB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">TypeA</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calling TypeA&#x27;s deref&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">TypeB</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = TypeA;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calling TypeB&#x27;s deref&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">TypeC</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = TypeB;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calling TypeC&#x27;s deref&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>(x: &amp;<span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I get &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">TypeA</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">TypeB</span>(a);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">TypeC</span>(b);</span><br><span class="line">  </span><br><span class="line">  <span class="title function_ invoke__">test</span>(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我写了上述的这些代码，企图验证是否会有连续的强制解引用发生。按照我上个段落的结论，我预想的 将 <code>c</code> 作为参数传入 <code>test</code> 函数，<code>c</code> 的类型 <code>TypeC</code> 上又有 <code>deref trait</code> 的实现，那么连续的强制解引用将会是 <code>TypeC -&gt; TypeB, TypeC -&gt; TypeA, TypeA -&gt; i32</code>，我们可以看到编译器首先并没有提示类型错误，我们再运行看看：</p>
<p><img src="/images/image-20241109000000451.png" alt="image-20241109000000451"></p>
<p>如结果所示，印证了预想，那么这就是一个连续的强制解引用的过程。Rust 之所依提供这个隐含的功能就是为了让我们省去手动做”连续的类型转换”的过程。我们再强调一下，这个强制类型转换发生需要符合的条件：</p>
<ol>
<li><code>&amp;T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;</code>  T 上有返回类型为 U 的解引用实现</li>
<li><code>&amp;mut T -&gt; &amp;mut U ===&gt; T: DerefMut&lt;Target=U&gt;</code>  T 上有返回类型为 U 的可变解引用实现</li>
<li><code>&amp;mut T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;</code> T 上有返回类型为 U 的解引用实现（可变的类型可以转换为不可变类型，但不可变不能转换成可变）</li>
</ol>
<h3 id="The-Drop-Trait"><a href="#The-Drop-Trait" class="headerlink" title="The Drop Trait"></a>The Drop Trait</h3><p>除了 Deref Trait 外，智能指针还拥有 Drop Trait。Drop Trait 是 Rust 设计用于内存管理的特征，当一个变量超出 scope 之后，自动释放其占用的内存。Drop Trait 的实现和 Deref Trait 异曲同工，本质也是执行该 Trait 下对应的 <code>drop method</code> , 当我们需要自定义释放内存的场景就可以手动实现 <code>drop method</code> ，让我们一样用例子看一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::<span class="built_in">Drop</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer of data &#123;&#125; is dropping...&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c1&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; is created.&quot;</span>, c1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c2&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; is created.&quot;</span>, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/images/image-20241109131227963.png" alt="image-20241109131227963"></p>
<p>结合所有权系统，当一个变量离开作用域以及不存在对其的任何引用，Rust 会自动释放变量占用的内存，这样就无需开发者手动管理内存。我们上面的代码就可以看到这个效果，内存释放是按照变量出栈顺序，即先进后出，创建顺序是 <code>c1 -&gt; c2</code>，销毁顺序则是 <code>c2 -&gt; c1</code>，如打印结果所示。</p>
<p>这里有一点需要注意，因为 Rust 已经有一套合理管理内存的机制 —— 离开作用域内存会自动被释放，所以是不支持我们直接手动调用 <code>xxx.drop()</code> 来释放内存的，这样会导致双重释放内存的错误（a double free error）。</p>
<h3 id="Trait-Objects"><a href="#Trait-Objects" class="headerlink" title="Trait Objects"></a>Trait Objects</h3><p>虽然 Rust 强调静态类型编译，需要有明确的数据类型，但为了实现代码的多态性，Rust 也提供了一种方案可以动态调度（dynamic dispatch）类型，它就是 <code>Trait Objects</code>。首先我们理解一下什么是动态调度：</p>
<h4 id="Dynamic-dispatch-动态调度"><a href="#Dynamic-dispatch-动态调度" class="headerlink" title="Dynamic dispatch 动态调度"></a>Dynamic dispatch 动态调度</h4><p>动态调度表示在编译时并不知道具体类型，而是在运行时才能确定类型。它与 static dispatch 相对，static dispatch 静态调度是指在编译时就已经确定了类型，一般我们没有特别处理的都属于静态调度，变量的类型是明确的，函数的入参类型也是确定的，所有的类型都是编译时就已经固定了的。而动态调度需要使用关键字 <code>dyn</code> ，来表示这是一个动态调度类型，我们需要结合 <code>Trait Objects</code> 这个概念一起使用。</p>
<p><code>Trait Objects</code> 是 Rust 提供应对有着同样行为的但所属不同类型的变量的事务，用官方的例子，比如我们现在要实现一个前端框架库，我们会拥有很多 <code>components</code> 组件，每个组件都是一个类型。</p>
<p>因为组件会有很多种，比如 Button、Select、Input，我们在声明 components 类型的时候，首先它是个可以更改长度的 list，所以 <code>components: vec![???]</code>，好了，这里就有一个问题出现了！<code>vec!</code> 里面的类型并不是我们以往固定的某一种类型，它可能是 <code>Button/Input/Select</code> 等等，这种情况我们就需要使用动态调度，表示这里的类型不是某一个固定类型，是多种类型。</p>
<p>具体使用方式，用 <code>dyn</code> 关键字表示这里是动态调度，<code>dyn</code> 后面跟的类型是一个 <code>trait</code>，<code>dyn xxxTrait</code> 则表示当前是一个 <code>trait objects</code> 类型。trait（特征）我们在上面有单独介绍，它用来描述某种行为，那么 <code>trait objects</code> 其实就是拥有同种行为的不同类型的对象，本质就是不同类型都对同一个 trait 进行了实现。我们上面这个组件的例子，就是 <code>Trait Objects</code> 的一个标准案例，组件本身都是不同的类型，但是它们都至少有某个或某些相同的行为，比如绘制功能，那么实现时就可以把绘制作为一个 trait，这些组件都有对于 绘制trait 的实现，这些组件便可以通过 <code>dyn Draw</code> 视为同一个 <code>trait object</code> 类型。但因为 <code>trait</code> 本身没有固定大小，所以它必须结合指针类型使用（指针类型拥有固定大小），如 <code>Box&lt;dyn Draw&gt;</code> 表示 <code>Draw trait objects</code> 类型。</p>
<p>用这个场景，我们具体实现下代码来理解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制trait</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Button类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  width: <span class="type">u32</span>,</span><br><span class="line">  height: <span class="type">u32</span>,</span><br><span class="line">  label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">  width: <span class="type">u32</span>,</span><br><span class="line">  height: <span class="type">u32</span>,</span><br><span class="line">  options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会继承绘制trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// do Button&#x27;s drawing stuff </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会继承绘制trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// do Select&#x27;s drawing stuff </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架库类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">  <span class="comment">// components list</span></span><br><span class="line">  components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;, <span class="comment">// a list of &quot;Draw trait objects&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是【动态调度 + trait objects】的使用方法，这种方式本质上其实是让我们有了可以同时使用不同的类型的能力，这就是动态调度的魔法。和泛型（generics）的不同之处就是这里，泛型只是声明时的多态，在调用时一次传入的还只是同一个类型，而动态调度是一次调用能传入多种类型，实现了真正的运行时多态。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h3><p><img src="/../images/smart-pointers/home_work_2.png" alt="home_work_2"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::DerefMut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> colored::Colorize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">        <span class="comment">// type Output;</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">create_file</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;Node;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">create_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;Node;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">list_contents</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">find_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 文件</span></span><br><span class="line">        <span class="title function_ invoke__">File</span>(<span class="type">String</span>),</span><br><span class="line">        <span class="comment">// 文件夹</span></span><br><span class="line">        <span class="title function_ invoke__">Folder</span>(FolderNode),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FolderNode</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        contents: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;Node&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">FileSystem</span> <span class="keyword">for</span> <span class="title class_">FolderNode</span> &#123;</span><br><span class="line">        <span class="comment">// 在当前文件夹下创建单个文件</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">create_file</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;Node &#123;</span><br><span class="line">            <span class="keyword">self</span>.contents.<span class="title function_ invoke__">push</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">File</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(name))));</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;/&#123;&#125; 添加文件 &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name, name);</span><br><span class="line">            <span class="keyword">self</span>.contents.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在当前文件夹下创建文件夹</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">create_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;Node &#123;</span><br><span class="line">            <span class="keyword">self</span>.contents.<span class="title function_ invoke__">push</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">Folder</span>(FolderNode &#123;</span><br><span class="line">                name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(name),</span><br><span class="line">                contents: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;)));</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;/&#123;&#125; 添加文件夹 &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name, name);</span><br><span class="line">            <span class="keyword">self</span>.contents.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值是一个可变的 FolderNode，因为可能需要继续修改 folder 内容</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">find_folder</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, target_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> FolderNode&gt; &#123;</span><br><span class="line">            <span class="comment">// 声明返回值为可变的，初始为 None</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">target</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> FolderNode&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历子目录，iter_mut() 允许返回可变的遍历对象</span></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">node</span> <span class="keyword">in</span> <span class="keyword">self</span>.contents.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">                <span class="comment">// deref_mut() 允许返回解引用后并可变的值</span></span><br><span class="line">                <span class="keyword">match</span> node.<span class="title function_ invoke__">deref_mut</span>() &#123;</span><br><span class="line">                    Node::<span class="title function_ invoke__">Folder</span>(folder) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> folder.name == target_name &#123;</span><br><span class="line">                            target = <span class="title function_ invoke__">Some</span>(folder);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// log error</span></span><br><span class="line">            <span class="keyword">if</span> target.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;[ERR] Cannot find this folder!&quot;</span>.<span class="title function_ invoke__">red</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列出文件夹下所有文件和文件夹（递归 recursion）</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">list_contents</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;======== /&#123;&#125; 当前目录结构 ========&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">            <span class="comment">// print current folder name</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;/&#123;&#125;&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印单个 node 下的内容，因为需要打印目录结构，子目录需要使用递归</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">print_node</span>(level: <span class="type">usize</span>, node: &amp;Node) &#123;</span><br><span class="line">                <span class="comment">// 除 root 外（非根目录），目录结构前缀逐级添加 &#x27;|[][][][]&#x27;</span></span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">level_prefix</span> = <span class="type">String</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">5</span> * level);</span><br><span class="line">                <span class="comment">// level &gt; 1 need append space prefix</span></span><br><span class="line">                <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">1</span>..(level) &#123;</span><br><span class="line">                    level_prefix.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;|    &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">match</span> node &#123;</span><br><span class="line">                    <span class="comment">// 当前 node 是文件，没有子目录</span></span><br><span class="line">                    Node::<span class="title function_ invoke__">File</span>(file_name) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// print current file name</span></span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, level_prefix, file_name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前 node 是文件夹，子目录需要继续调用 print_node</span></span><br><span class="line">                    Node::<span class="title function_ invoke__">Folder</span>(folder) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// print current folder name</span></span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>, level_prefix, folder.name);</span><br><span class="line">                        folder</span><br><span class="line">                            .contents</span><br><span class="line">                            .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                            .for_each(|n| <span class="title function_ invoke__">print_node</span>(level + <span class="number">1</span>, n));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.contents.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">                <span class="comment">// 空文件夹</span></span><br><span class="line">                <span class="number">0</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前为有内容的文件夹</span></span><br><span class="line">                _ =&gt; &#123;</span><br><span class="line">                    <span class="keyword">for</span> (_, content) <span class="keyword">in</span> <span class="keyword">self</span>.contents.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">                        <span class="comment">// 当前文件夹 level 1，子文件夹 initial level = 2</span></span><br><span class="line">                        <span class="title function_ invoke__">print_node</span>(<span class="number">2</span>, &amp;content);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;================ END =================&quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">root</span> = FolderNode &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;root&quot;</span>),</span><br><span class="line">        contents: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base on root</span></span><br><span class="line">    &#123;</span><br><span class="line">        root.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file_1.txt&quot;</span>);</span><br><span class="line">        root.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file_2.txt&quot;</span>);</span><br><span class="line">        root.<span class="title function_ invoke__">create_folder</span>(<span class="string">&quot;folder_1&quot;</span>);</span><br><span class="line">        root.<span class="title function_ invoke__">create_folder</span>(<span class="string">&quot;folder_2&quot;</span>);</span><br><span class="line">        root.<span class="title function_ invoke__">list_contents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base on root/folder_1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">folder_1</span> = root.<span class="title function_ invoke__">find_folder</span>(<span class="string">&quot;folder_1&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        folder_1.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file_11.txt&quot;</span>);</span><br><span class="line">        folder_1.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file_12.txt&quot;</span>);</span><br><span class="line">        folder_1.<span class="title function_ invoke__">create_folder</span>(<span class="string">&quot;folder_11&quot;</span>);</span><br><span class="line">        folder_1.<span class="title function_ invoke__">list_contents</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">folder_11</span> = folder_1.<span class="title function_ invoke__">find_folder</span>(<span class="string">&quot;folder_11&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        folder_11.<span class="title function_ invoke__">create_folder</span>(<span class="string">&quot;folder_111&quot;</span>);</span><br><span class="line">        folder_11.<span class="title function_ invoke__">list_contents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base on root/folder_2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">folder_2</span> = root.<span class="title function_ invoke__">find_folder</span>(<span class="string">&quot;folder_2&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        folder_2.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file_21.txt&quot;</span>);</span><br><span class="line">        folder_2.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;file_22.txt&quot;</span>);</span><br><span class="line">        folder_2.<span class="title function_ invoke__">create_folder</span>(<span class="string">&quot;folder_21&quot;</span>);</span><br><span class="line">        folder_2.<span class="title function_ invoke__">list_contents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.<span class="title function_ invoke__">list_contents</span>();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Test finder_folder error case&quot;</span>);</span><br><span class="line">        root.<span class="title function_ invoke__">find_folder</span>(<span class="string">&quot;not_exist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/../images/smart-pointers/home_work_2_result.png" alt="home_work_2_result"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marniewu.github.io/2024/10/24/smart-pointers/" data-id="cm48q2kom0002gi16am9h14ef" data-title="Smart Pointers" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/11/01/first-project/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          First Project
        
      </div>
    </a>
  
  
    <a href="/2024/10/23/rust-basic/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Rust Basic</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/02/%E6%B3%9B%E5%9E%8B/">泛型</a>
          </li>
        
          <li>
            <a href="/2024/11/01/first-project/">First Project</a>
          </li>
        
          <li>
            <a href="/2024/10/24/smart-pointers/">Smart Pointers</a>
          </li>
        
          <li>
            <a href="/2024/10/23/rust-basic/">Rust Basic</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Marnie Wu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>