<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Marnie Wu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Marnie Wu">
<meta property="og:url" content="https://marniewu.github.io/index.html">
<meta property="og:site_name" content="Marnie Wu">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Marnie Wu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Marnie Wu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Marnie Wu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://marniewu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-first-project" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/01/first-project/" class="article-date">
  <time class="dt-published" datetime="2024-11-01T08:06:44.000Z" itemprop="datePublished">2024-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/01/first-project/">First Project</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>安装 anchor —— Solana 智能合约框架</p>
<p>1.用 cargo 安装 avm ，Anchor 版本管理器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https://github.com/coral-xyz/anchor --tag v0.30.1 anchor-cli</span><br></pre></td></tr></table></figure>

<p>2.使用 avm 安装最新版本 anchor</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avm install latest</span><br></pre></td></tr></table></figure>

<p>3.检查安装好的版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchor --version</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marniewu.github.io/2024/11/01/first-project/" data-id="cm3buz5tw00004l16d7yr595c" data-title="First Project" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-smart-pointers" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/24/smart-pointers/" class="article-date">
  <time class="dt-published" datetime="2024-10-24T07:41:13.000Z" itemprop="datePublished">2024-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/24/smart-pointers/">Smart Pointers</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="智能指针-Smart-Pointers"><a href="#智能指针-Smart-Pointers" class="headerlink" title="智能指针 Smart Pointers"></a>智能指针 Smart Pointers</h2><p>首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。</p>
<p>在 Rust 中最常见的指针就是引用（reference），引用变量向被它引用的变量借用（borrow）它指向的数据，这意味着它们自身是没有对该数据的所有权（ownership）的。</p>
<p>引用只包含一个指向被引用变量的指针，除此之外，引用就再无其他功能了。而 Rust 是静态编译语言，在编译期间就需要确定变量数据的大小以及何时释放。所以设计了智能指针，在普通指针的基础上，还包含了当前长度（len）、最大长度（capacity）等字段，这些都是用来确定指针类型指向的那块数据所需的内存 size 的字段。像是我们之前用过的 <code>String</code> 、<code>Vec</code> 都是智能指针数据类型。</p>
<p>不同于普通指针，智能指针是具有所有权的指针，且实现了 Deref（解引用）和 Drop（清理）两个 trait（特征），这使得他们可以像指针一样解引用并在离开作用域是自动清理资源。这是对智能指针是什么的一个大致概括，具体功能可以通过后面更多的实际例子去理解更为自然。</p>
<h3 id="为什么存在智能指针？"><a href="#为什么存在智能指针？" class="headerlink" title="为什么存在智能指针？"></a>为什么存在智能指针？</h3><h4 id="性能管理-—-处理大体量的数据"><a href="#性能管理-—-处理大体量的数据" class="headerlink" title="性能管理 — 处理大体量的数据"></a>性能管理 — 处理大体量的数据</h4><p>栈是我们用于快速读写的内存空间，并不适合存储过大的数据。相对来说，简单的数据类型会被分配在栈上，但针对简单却大体量数据，我们就不应该再继续存储在栈上了，栈溢出会引起程序的崩溃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">大体量数据，长度为 1_000_000 的数组，数组默认是分配的栈内存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr_stack</span> = [<span class="number">0</span>; <span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> arr_stack &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，我们会得到如下报错：</p>
<p><img src="/images/image-20241031162223186.png" alt="image-20241031162223186"></p>
<p>正如前面所说 —— 栈溢出，程序中止运行了。</p>
<h4 id="处理更复杂的数据结构"><a href="#处理更复杂的数据结构" class="headerlink" title="处理更复杂的数据结构"></a>处理更复杂的数据结构</h4><p>Rust 是静态编译语言，这意味着它在编译时期就是需要知道每个数据所需内存大小，而针对一些复杂的数据结构，如递归结构、分享结构【❓TODO 这是啥】等，是没有固定大小的，而智能指针就是为了解决这一问题设计的。</p>
<p>举个例子，常规 <code>enum</code> ，因为一次只会使用 <code>enum</code> 的某一个值，所以该 <code>enum</code> 的所需内存大小取决于其下面内存占用最大的一个枚举值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  Quit,</span><br><span class="line">  Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">  <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum Message 中所需内存最大的是 ChangeColor，</span></span><br><span class="line"><span class="comment">// 则该 enum 所需内存为 ChangeColor 所需的内存大小</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Message::Quit;</span><br></pre></td></tr></table></figure>

<p>更复杂的数据结构，递归 <code>enum</code> 类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List), <span class="comment">// 动态大小，无法确定 size</span></span><br><span class="line">  Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于递归 <code>enum</code> 来说，基于我们前面计算 <code>enum</code> 大小的方式，会发现我们并不能知道哪个是内存大小最大的枚举值，递归的枚举值是动态的，所以我们无法得出递归类型的数据大小。</p>
<h4 id="【TODO】在普通指针基础上，完善更多的功能"><a href="#【TODO】在普通指针基础上，完善更多的功能" class="headerlink" title="【TODO】在普通指针基础上，完善更多的功能"></a>【TODO】在普通指针基础上，完善更多的功能</h4><p>❓TODO：所有权、悬垂指针、动态大小？</p>
<h4 id="【TODO】RC-智能指针"><a href="#【TODO】RC-智能指针" class="headerlink" title="【TODO】RC 智能指针"></a>【TODO】RC 智能指针</h4><p>智能指针是 Rust 确保其安全性的一种方式。智能指针是一种包裹了数据和提供了一些额外功能的数据结构，例如所有权（ownership）和引用计数（reference counting）。Rust 设计了多种智能指针的数据类型，适用于多种不同的场景。</p>
<h3 id="Box-Smart-Pointer"><a href="#Box-Smart-Pointer" class="headerlink" title="Box Smart Pointer"></a>Box Smart Pointer</h3><p>Box 智能指针是 Rust 中智能指针的一种，它是在栈上拥有固定大小的指针，但其指向的数据，在堆上可以是任意大小的数据。所以当我们使用了 Box 智能指针，我们是可以在编译时就知道所需内存大小的。因此上面说到的编译时无法计算内存大小的问题，便就迎刃而解了。</p>
<p>我们将改写上面递归 <code>enum</code> 的例子，用 Box 智能指针来解决问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将递归嵌套的 List 类型改写成 Box&lt;List&gt; 智能指针类型</span></span><br><span class="line"><span class="comment">// 智能指针在栈侧是拥有固定大小的指针，可以顺利通过编译</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">  Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123; Cons, Nil &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// Box::new() 创建 Box 智能指针类型变量</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>智能指针之所以功能强大，还因为 Rust 为其实现了两种特征（trait），Deref Trait 和 Drop Trait，让我们一起了解下。</p>
<h3 id="The-Deref-Trait"><a href="#The-Deref-Trait" class="headerlink" title="The Deref Trait"></a>The Deref Trait</h3><p>Deref Trait 解引用是为了让智能指针能像普通指针一样使用而实现的特征（trait）。这句话有两个关键点：</p>
<ol>
<li><p>什么是 trait（特征）？</p>
</li>
<li><p>什么叫像普通指针一样使用？</p>
</li>
</ol>
<p>我们逐一了解一下：）</p>
<h4 id="Traits-特征"><a href="#Traits-特征" class="headerlink" title="Traits 特征"></a>Traits 特征</h4><p> 特征（traits）是 Rust 设计出可以让不同类型拥有相同行为（behavior）的一种实现，在描述某种或者说某类行为时可以包含1个或者多个方法（methods），即特征就是我们用来使得不同类型能够共享（sharing）同一批方法的手段。</p>
<p>我们看一下 trait 的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">TraitA</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">method_A</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">method_B</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般我们描述 trait 时，会包含一个或多个方法的签名，如果对方法写了具体实现，则作为该方法的默认行为。我们也可以在具体类型上重写（overwrite）特征下的方法，来自定义不同类型上的实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StructA</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// once impl A for B means B is shared with all methods in A</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TraitA</span> <span class="keyword">for</span> <span class="title class_">StructA</span> &#123;</span><br><span class="line">    <span class="comment">// overwrite method_A of trait TraitA</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method_a</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>([<span class="string">&quot;I&#x27;m&quot;</span>, &amp;<span class="keyword">self</span>.name].<span class="title function_ invoke__">join</span>(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = StructA &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;aaa&quot;</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// call the methods of trait</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">name</span> = a.<span class="title function_ invoke__">method_a</span>();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, name);</span><br><span class="line">  </span><br><span class="line">  a.<span class="title function_ invoke__">method_b</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 定义很多内置的特征，并为我们提供了 <code>derive</code> 属性，用于在一个 struct 或 enum 上生成对某个 trait 的实现的相关代码，这里的代码就是将该 trait 所拥有的默认实现复制过来。这样我们就能快速的拥有一个 trait 的所有默认行为，内置的特征需要通过 <code>use xxx</code> 导入之后使用。</p>
<h4 id="像普通指针一样使用"><a href="#像普通指针一样使用" class="headerlink" title="像普通指针一样使用"></a>像普通指针一样使用</h4><p>其实指的就是，可以对于指针变量使用 <code>*</code> 操作符，我们知道因为所有权的关系，我们只能对指针类型的变量进行借用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// &amp;String</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, x, y, x == y); <span class="comment">// ❌ [ERROR] can&#x27;t compare `String` with `&amp;String`.</span></span><br></pre></td></tr></table></figure>

<p>这里编译会报错，因为第 3 行无法将不同类型的两个值进行比较，x 是 String 类型，而 y 是 a reference to String。</p>
<p>y 就是借用了 x，借用就意味着其实就只是拿到了一个内存地址，那么当我们需要直接使用数据时（如：上面做比较的场景 x &#x3D;&#x3D; y）就需要用 <code>*</code> 操作符做解引用，拿到内存地址对应的数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// &amp;String</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, x, y, x == *y); <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>*</code> 操作符实现了 deref，还有包括我们经常使用的 <code>.</code> 操作符，是默认带有解引用功能的，通过例子看一下：</p>
<p><img src="/images/image-20241107133927309.png" alt="image-20241107133927309"></p>
<p>可以看到，当我们在使用 <code>.</code> 操作符时，会得到自动解引用之后的结果（倒数第 2 行），并且最后一行我们看到，无论是多加了多少层的引用，都能得到最终指向的那块数据。这就是 <code>.</code> 操作符上带有的魔法之一 —— 自动解引用。</p>
<p>为了更好的理解解引用特征，我们手动还原一个自己的 <code>MyBox</code> 智能指针类型。</p>
<h4 id="手动还原-Box-智能指针"><a href="#手动还原-Box-智能指针" class="headerlink" title="手动还原 Box 智能指针"></a>手动还原 Box 智能指针</h4><p>首先，<code>MyBox</code> 是一个结构体，它只有一个字段 —— 被他包裹的类型，且不需要字段名，即我们采用<strong>元组结构体</strong>（tuple struct）构造 <code>MyBox</code>。这里还需要使用泛型 <code>T</code>，被包裹的类型是由调用的时候传入的。</p>
<blockquote>
<p>这一部分需要补充泛型（generics）的内容，可以参考 <a target="_blank" rel="noopener" href="https://course.rs/basic/trait/generic.html">https://course.rs/basic/trait/generic.html</a></p>
</blockquote>
<p>使用泛型的规范是，先声明 <code>xxx&lt;T&gt;</code> 后使用 <code>structNameXXX(T)、functionNameXXX(x: T)</code> 等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br></pre></td></tr></table></figure>

<p>接着实现 <code>new</code> 方法，在 Rust 中使用 <code>impl</code> 来定义方法，如 <code>impl Circle</code> ，泛型用 <code>impl&lt;T&gt; Circle&lt;T&gt;</code> 。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，在 <code>MyBox</code> 上实现 <code>deref trait</code> ，可以参考官网 <code>Deref Trait</code> 给出的示例实现：</p>
<p><img src="/images/image-20241108213447782.png" alt="image-20241108213447782"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123; <span class="comment">// Target 就是目标类型 T</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span> <span class="comment">// 因为 MyBox 是元组结构体，对应的值 self.0</span></span><br><span class="line">    &#125;  <span class="comment">// 注意：解引用并不会涉及所有权转移，返回的值还是一个引用值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以在 MyBox 类型变量上使用解引用功能了，让我们试下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Marnie&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Marnie&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, a, *n, a == *n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20241108224953665.png" alt="image-20241108224953665"></p>
<p>以上就是模拟 MyBox 并实现 Deref Trait 的大致过程，当我们使用 <code>*v</code> 时，就会去 <code>v</code> 对应的类型 <code>T</code> 上找 <code>deref</code> 方法，即 <code>*(v.deref())</code>，所以但凡是实现了 <code>Deref Trait</code> 的类型变量都可以使用 <code>*</code> 操作符来解引用。</p>
<p>在官网关于”使用 Deref Trait 将智能指针像常规引用一样对待”有很详细的介绍，细节可以更多的参考 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait%EF%BC%8C%E8%BF%99%E9%87%8C%E5%86%8D%E6%8F%90%E4%B8%80%E7%82%B9%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A">https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait，这里再提一点比较重要的内容：</a></p>
<h4 id="Implicit-Deref-Coerions-隐式的强制解引用"><a href="#Implicit-Deref-Coerions-隐式的强制解引用" class="headerlink" title="Implicit Deref Coerions 隐式的强制解引用"></a>Implicit Deref Coerions 隐式的强制解引用</h4><p>在 Deref Trait 相关内容下，有一个知识点叫 Deref coerion 强制解引用，意思是在某些场景下，Rust 会自动发生解引用。</p>
<p>这里会发生自动解引用的场景是在变量作为参数传入方法 methods 或者函数 functions 时，若传入变量类型实现了 Deref Trait，变会发生自动解引用的行为。我们分析看下官方的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里写了一个 <code>hello</code> 函数，接收 string slice 类型的参数，如果我们继续用前面 <code>MyBox</code> 的实例 <code>n</code> 传入 <code>hello</code> 函数 <code>hello(&amp;n)</code>，如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Marnie&quot;</span>)); <span class="comment">// MyBox&lt;String&gt;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;n); <span class="comment">// 🤔...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现，编辑器并没有提示任何编译错误，这里就是强制解引用的作用。</p>
<p>首先，我们传入的 <code>n</code> 本身是个 <code>MyBox&lt;String&gt;</code> 类型，按照强制解引用的发生规则 —— 当我们将某个类型作为参数传入函数或者方法时，会自动发生解引用。<code>MyBox</code>类型的解引用实现我们前面已经还原了，那么这一步强制解引用就相当于调用 <code>n.deref()</code>，则 <code>&amp;n</code> 从 <code>&amp;MyBox&lt;String&gt;</code> -&gt; <code>&amp;String</code>，这么看起来还是不对呀，目标参数接收的是 <code>String Slice</code>，现在还只是 <code>String</code>。好，这里注意 📢，当类型上实现了 Deref Trait 的话强制解引用会一直继续自动发生，即可能发生连续的解引用。</p>
<p>我们上一步强制解引用得到的是类型 <code>String</code>，在标准库里 <code>String</code> 也对应实现了 <code>Deref Trait</code> ，所以会再次做强制解引用，我们可以查看官网看到标准库中对于 <code>String</code> 上 <code>Deref Trait</code> 实现的签名描述：</p>
<p><img src="/images/image-20241108233250046.png" alt="image-20241108233250046"></p>
<p>可以看到 <code>String</code> 的 <code>deref</code> 方法返回 <code>string slice</code> 类型，所以才满足了 <code>hello</code> 函数，并不会有编译问题。</p>
<p>关于这个连续强制解引用，我尝试再用一些自定义的类型例子来验证一下是否如此：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeA</span>(<span class="type">i32</span>); <span class="comment">// i32</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeB</span>(TypeA); <span class="comment">// TypeA</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeC</span>(TypeB); <span class="comment">// TypeB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">TypeA</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calling TypeA&#x27;s deref&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">TypeB</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = TypeA;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calling TypeB&#x27;s deref&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">TypeC</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = TypeB;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calling TypeC&#x27;s deref&quot;</span>);</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>(x: &amp;<span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I get &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">TypeA</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">TypeB</span>(a);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">TypeC</span>(b);</span><br><span class="line">  </span><br><span class="line">  <span class="title function_ invoke__">test</span>(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我写了上述的这些代码，企图验证是否会有连续的强制解引用发生。按照我上个段落的结论，我预想的 将 <code>c</code> 作为参数传入 <code>test</code> 函数，<code>c</code> 的类型 <code>TypeC</code> 上又有 <code>deref trait</code> 的实现，那么连续的强制解引用将会是 <code>TypeC -&gt; TypeB, TypeC -&gt; TypeA, TypeA -&gt; i32</code>，我们可以看到编译器首先并没有提示类型错误，我们再运行看看：</p>
<p><img src="/images/image-20241109000000451.png" alt="image-20241109000000451"></p>
<p>如结果所示，印证了预想，那么这就是一个连续的强制解引用的过程。Rust 之所依提供这个隐含的功能就是为了让我们省去手动做”连续的类型转换”的过程。我们再强调一下，这个强制类型转换发生需要符合的条件：</p>
<ol>
<li><code>&amp;T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;</code>  T 上有返回类型为 U 的解引用实现</li>
<li><code>&amp;mut T -&gt; &amp;mut U ===&gt; T: DerefMut&lt;Target=U&gt;</code>  T 上有返回类型为 U 的可变解引用实现</li>
<li><code>&amp;mut T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;</code> T 上有返回类型为 U 的解引用实现（可变的类型可以转换为不可变类型，但不可变不能转换成可变）</li>
</ol>
<h3 id="The-Drop-Trait"><a href="#The-Drop-Trait" class="headerlink" title="The Drop Trait"></a>The Drop Trait</h3><p>除了 Deref Trait 外，智能指针还拥有 Drop Trait。Drop Trait 是 Rust 设计用于内存管理的特征，当一个变量超出 scope 之后，自动释放其占用的内存。Drop Trait 的实现和 Deref Trait 异曲同工，本质也是执行该 Trait 下对应的 <code>drop method</code> , 当我们需要自定义释放内存的场景就可以手动实现 <code>drop method</code> ，让我们一样用例子看一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::<span class="built_in">Drop</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer of data &#123;&#125; is dropping...&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c1&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; is created.&quot;</span>, c1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c2&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; is created.&quot;</span>, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/images/image-20241109131227963.png" alt="image-20241109131227963"></p>
<p>结合所有权系统，当一个变量离开作用域以及不存在对其的任何引用，Rust 会自动释放变量占用的内存，这样就无需开发者手动管理内存。我们上面的代码就可以看到这个效果，内存释放是按照变量出栈顺序，即先进后出，创建顺序是 <code>c1 -&gt; c2</code>，销毁顺序则是 <code>c2 -&gt; c1</code>，如打印结果所示。</p>
<p>这里有一点需要注意，因为 Rust 已经有一套合理管理内存的机制 —— 离开作用域内存会自动被释放，所以是不支持我们直接手动调用 <code>xxx.drop()</code> 来释放内存的，这样会导致双重释放内存的错误（a double free error）。</p>
<h3 id="Trait-Objects"><a href="#Trait-Objects" class="headerlink" title="Trait Objects"></a>Trait Objects</h3><p>虽然 Rust 强调静态类型编译，需要有明确的数据类型，但为了实现代码的多态性，Rust 也提供了一种方案可以动态调度（dynamic dispatch）类型，它就是 <code>Trait Objects</code>。首先我们理解一下什么是动态调度：</p>
<h4 id="Dynamic-dispatch-动态调度"><a href="#Dynamic-dispatch-动态调度" class="headerlink" title="Dynamic dispatch 动态调度"></a>Dynamic dispatch 动态调度</h4><p>动态调度表示在编译时并不知道具体类型，而是在运行时才能确定类型。它与 static dispatch 相对，static dispatch 静态调度是指在编译时就已经确定了类型，一般我们没有特别处理的都属于静态调度，变量的类型是明确的，函数的入参类型也是确定的，所有的类型都是编译时就已经固定了的。而动态调度需要使用关键字 <code>dyn</code> ，来表示这是一个动态调度类型，我们需要结合 <code>Trait Objects</code> 这个概念一起使用。</p>
<p><code>Trait Objects</code> 是 Rust 提供应对有着同样行为的但所属不同类型的变量的事务，用官方的例子，比如我们现在要实现一个前端框架库，我们会拥有很多 <code>components</code> 组件，每个组件都是一个类型。</p>
<p>因为组件会有很多种，比如 Button、Select、Input，我们在声明 components 类型的时候，首先它是个可以更改长度的 list，所以 <code>components: vec![???]</code>，好了，这里就有一个问题出现了！<code>vec!</code> 里面的类型并不是我们以往固定的某一种类型，它可能是 <code>Button/Input/Select</code> 等等，这种情况我们就需要使用动态调度，表示这里的类型不是某一个固定类型，是多种类型。</p>
<p>具体使用方式，用 <code>dyn</code> 关键字表示这里是动态调度，<code>dyn</code> 后面跟的类型是一个 <code>trait</code>，<code>dyn xxxTrait</code> 则表示当前是一个 <code>trait objects</code> 类型。trait（特征）我们在上面有单独介绍，它用来描述某种行为，那么 <code>trait objects</code> 其实就是拥有同种行为的不同类型的对象，本质就是不同类型都对同一个 trait 进行了实现。我们上面这个组件的例子，就是 <code>Trait Objects</code> 的一个标准案例，组件本身都是不同的类型，但是它们都至少有某个或某些相同的行为，比如绘制功能，那么实现时就可以把绘制作为一个 trait，这些组件都有对于 绘制trait 的实现，这些组件便可以通过 <code>dyn Draw</code> 视为同一个 <code>trait object</code> 类型。但因为 <code>trait</code> 本身没有固定大小，所以它必须结合指针类型使用（指针类型拥有固定大小），如 <code>Box&lt;dyn Draw&gt;</code> 表示 <code>Draw trait objects</code> 类型。</p>
<p>用这个场景，我们具体实现下代码来理解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制trait</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Button类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  width: <span class="type">u32</span>,</span><br><span class="line">  height: <span class="type">u32</span>,</span><br><span class="line">  label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">  width: <span class="type">u32</span>,</span><br><span class="line">  height: <span class="type">u32</span>,</span><br><span class="line">  options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会继承绘制trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// do Button&#x27;s drawing stuff </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会继承绘制trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// do Select&#x27;s drawing stuff </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架库类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">  <span class="comment">// components list</span></span><br><span class="line">  components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;, <span class="comment">// a list of &quot;Draw trait objects&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是【动态调度 + trait objects】的使用方法，这种方式本质上其实是让我们有了可以同时使用不同的类型的能力，这就是动态调度的魔法。和泛型（generics）的不同之处就是这里，泛型只是声明时的多态，在调用时一次传入的还只是同一个类型，而动态调度是一次调用能传入多种类型，实现了真正的运行时多态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marniewu.github.io/2024/10/24/smart-pointers/" data-id="cm3buz5u000024l163tpk48mv" data-title="Smart Pointers" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust-basic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/23/rust-basic/" class="article-date">
  <time class="dt-published" datetime="2024-10-22T16:00:00.000Z" itemprop="datePublished">2024-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/23/rust-basic/">Rust Basic</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="入门-Getting-Started"><a href="#入门-Getting-Started" class="headerlink" title="入门 Getting Started"></a>入门 Getting Started</h2><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>静态类型语言（statically typed）：在编译时就确定了所有表达式的类型</p>
<p>强类型语言（strongly typed）：一切皆需要明确的类型声明</p>
<ul>
<li><p>rustc：rust 编译器（compiler）</p>
<ul>
<li>检查 rust 是否安装成功：<code>rustup --version</code></li>
<li>将某个 rust 文件编译成二进制（binary）文件：<code>rustc &lt;file_name&gt;.rs</code></li>
</ul>
</li>
<li><p>rustup：rust 安装器和版本管理工具</p>
<ul>
<li><code>rustup update</code> 升级 rust</li>
<li><code>rustup doc</code> 打开本地 rust 文档</li>
</ul>
</li>
<li><p>命名规则（naming rule）：蛇形式（snake_case）</p>
</li>
<li><p>语句（statement）：一定要加分号（semicolon），表示执行某个操作但没有返回值的某个指令</p>
<ul>
<li>表达式语句：以分号结尾的表达式</li>
<li>声明语句</li>
</ul>
</li>
<li><p>表达式（expression）：主要用于计算求值（expression-base language）</p>
</li>
</ul>
<h3 id="Crate"><a href="#Crate" class="headerlink" title="Crate"></a>Crate</h3><p>用 rust 写的库或者可执行程序 a rust library or executable program</p>
<p>crate.io - rust 官方包注册表</p>
<h3 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h3><p>rust 包管理器 rust package manager</p>
<ul>
<li>支持管理项目依赖 <code>cargo update</code></li>
<li>支持编译、运行项目 <code>cargo build, cargo run</code></li>
<li>支持上传 crates.io <code>cargo publish</code></li>
<li>Cargo.toml：dependencies declaration file</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup a new project dir</span></span><br><span class="line">cargo new &lt;project_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile project [debug or release version]</span></span><br><span class="line">cargo build [--release]</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile project and execute [debug or release version]</span></span><br><span class="line">cargo run [--release]</span><br><span class="line"></span><br><span class="line"><span class="comment">// update all dependencies (keep semi-version 0.8.5 -&gt; 0.8.latest)</span></span><br><span class="line">cargo update</span><br></pre></td></tr></table></figure>

<h2 id="通用概念-Common-Concepts"><a href="#通用概念-Common-Concepts" class="headerlink" title="通用概念 Common Concepts"></a>通用概念 Common Concepts</h2><h3 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h3><p>默认都是不可变变量（immutable variables），不用声明类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p>声明可变变量（mutable variables），在运行时才会确定变量的值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">x = <span class="number">6</span>; <span class="comment">// 若这句不运行，则 x 值还是 5</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<h3 id="作用域规则-Scoping-Rules"><a href="#作用域规则-Scoping-Rules" class="headerlink" title="作用域规则 Scoping Rules"></a>作用域规则 Scoping Rules</h3><p>作用域是一个变量在程序中的有效范围，从变量声明的点开始知道当前作用域的结束就是一个有效范围。</p>
<p>作用域范围一般分为 函数作用域、代码块作用域。</p>
<p>不可变变量、可变变量、常量都是遵循这个作用域规则</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">foo_global_variable</span> :<span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// the start of the block</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo_local_variable</span> :<span class="type">i32</span> = <span class="number">2</span>; <span class="comment">// defined in current block, only can access in current block</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of foo_global_variable is: &#123;&#125;&quot;</span>, foo_global_variable); <span class="comment">// ✅ access anywhere within foo_block</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of foo_local_variable is: &#123;&#125;&quot;</span>, foo_local_variable);</span><br><span class="line">  &#125; <span class="comment">// the end of the block</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The value of foo_local_variable is: &#123;&#125;&quot;</span>, foo_local_variable); <span class="comment">// ❌ outer of the block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遮蔽-Shadowing"><a href="#遮蔽-Shadowing" class="headerlink" title="遮蔽 Shadowing"></a>遮蔽 Shadowing</h3><p>let 不可变变量支持重定义（遮蔽 shadowing）：虽然是不可变变量，但是可以用过去的值重新赋值，且可更改类型（与 <code>mut</code> 的不同之处）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>

<p>块内遮蔽（shadowing）也遵循作用域规则，块内重定义变量的操作结果对外是屏蔽的，在块外访问到的还是原值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the start of the block</span></span><br><span class="line">       <span class="comment">// 遮蔽（shadowing）</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x); <span class="comment">// ✅ The value of x is: 2</span></span><br><span class="line">    &#125; <span class="comment">// the end of the block</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x); <span class="comment">// ✅ The value of x is: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量-Constants"><a href="#常量-Constants" class="headerlink" title="常量 Constants"></a>常量 Constants</h3><p>声明常量必须要带类型（data types）注释（annotation），在编译时期就确定了变量的值，命名规范大写蛇形式（UPPER_SNAKE_CASE）</p>
<p>编译后是直接替换值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u32: unsigned 32-bit integer 无符号32位整数</span></span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, THREE_HOURS_IN_SECONDS); <span class="comment">// 🎯 编译后：println!(&quot;&#123;&#125;&quot;, 60 * 60 * 3)</span></span><br></pre></td></tr></table></figure>

<h3 id="静态变量-Static"><a href="#静态变量-Static" class="headerlink" title="静态变量 Static"></a>静态变量 Static</h3><p>特点如上同常量</p>
<p>作用域（scope）：在整个程序中共享，可以再多个线程之间共享 —— 即 全局变量！！</p>
<p>编译后是指向引用地址</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> A : <span class="type">i32</span> = <span class="number">1</span>; <span class="comment">// 假设这个 static 变量分配的内存地址为 0x123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, A); <span class="comment">// 🎯 编译后：存在对 A 的引用，指向 A 的内存地址</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型 Data Types"></a>数据类型 Data Types</h3><h4 id="原始类型-Primitive-Types"><a href="#原始类型-Primitive-Types" class="headerlink" title="原始类型 Primitive Types"></a>原始类型 Primitive Types</h4><h5 id="整数型-Integer-Types"><a href="#整数型-Integer-Types" class="headerlink" title="整数型 Integer Types"></a>整数型 Integer Types</h5><p>默认 <code>i32</code></p>
<p>如果可能是负数则用 <code>i[bit]</code>，反之用 <code>u[bit]</code>，位数由运行代码的电脑决定</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 二进制位数和[整/负]数大小范围的关系</span></span><br></pre></td></tr></table></figure>

<h5 id="浮点数型-Floating-Point-Types"><a href="#浮点数型-Floating-Point-Types" class="headerlink" title="浮点数型 Floating-Point Types"></a>浮点数型 Floating-Point Types</h5><p>默认 <code>f64</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br></pre></td></tr></table></figure>

<h5 id="布尔型-The-Boolean-Types"><a href="#布尔型-The-Boolean-Types" class="headerlink" title="布尔型 The Boolean Types"></a>布尔型 The Boolean Types</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// both are 👌🏻</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h5 id="文本类型-Textual-Types"><a href="#文本类型-Textual-Types" class="headerlink" title="文本类型 Textual Types"></a>文本类型 Textual Types</h5><p><code>char</code> 字符型</p>
<p><code>unicode</code> 编码，1 char &#x3D; 4 bytes，默认单引号包裹的文字（单个文字）表示字符型变量，也可以显式声明类型,</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="复合类型-Compound-Types"><a href="#复合类型-Compound-Types" class="headerlink" title="复合类型 Compound Types"></a>复合类型 Compound Types</h4><p>🕵🏻‍♂️ ：下面字符串类型建议看完所有权部分知识，再去理解比较好！！</p>
<h5 id="Character-encoding-format"><a href="#Character-encoding-format" class="headerlink" title="Character encoding format"></a>Character encoding format</h5><ul>
<li>ASCII：1 character &#x3D; 7 bits binary，total 128 characters（max decimal number of 7-bit binary number）</li>
<li>UTF-8：1 character &#x3D; 1～4 bytes &#x3D; (1～4) x 8 bits，total 1,112,064 character</li>
</ul>
<h4 id="🎯-TODO：Memory-management-ownership-in-Rust"><a href="#🎯-TODO：Memory-management-ownership-in-Rust" class="headerlink" title="🎯 TODO：Memory management &amp; ownership in Rust"></a>🎯 TODO：Memory management &amp; ownership in Rust</h4><p><img src="/images/image-20241010155641561.png" alt="image-20241010155641561"></p>
<p><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/memory-management-rust-amit-nadiger#:~:text=The%20.,string%20literals%20and%20other%20constants">https://www.linkedin.com/pulse/memory-management-rust-amit-nadiger#:~:text=The%20.,string%20literals%20and%20other%20constants</a>.</p>
<p>【TODO】compile binary –&gt; read-only memory 是什么？</p>
<p>【TODO】Machine words 是什么？</p>
<p>【TODO】Rc smart pointer  reference counted pointer</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=rDoqT-a6UFg&t=118s">Visualizing memory layout of Rust’s data types</a></p>
<h5 id="String-文本字符串型"><a href="#String-文本字符串型" class="headerlink" title="String 文本字符串型"></a><code>String</code> 文本字符串型</h5><p>一串动态长度的 UTF-8 编码序列，用来表示文本字符串。UTF-8 编码规则用 1～4 个字节表示一个字符，是默认拥有所有权的类型。</p>
<p>动态分配大小所以存储在 heap 上，对应栈上的变量存储指针（ptr &#x3D; 内存地址）、长度（len &#x3D; 实际长度）、容量（capacity &#x3D; 可用长度）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 类型值内置了修改和其他的各种方法</span></span><br><span class="line"><span class="comment">// mutable variable</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// modify string s</span></span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="comment">// replace first character of string s</span></span><br><span class="line">s.<span class="title function_ invoke__">replace_range</span>(<span class="number">0</span>..<span class="number">1</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line"><span class="comment">// check the result</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);  <span class="comment">// ✅ 输出：s = Hello!</span></span><br></pre></td></tr></table></figure>

<h5 id="String-Slice-文本字符串切片类型"><a href="#String-Slice-文本字符串切片类型" class="headerlink" title="String Slice 文本字符串切片类型"></a><code>String Slice</code> 文本字符串切片类型</h5><p>我们把某个字符串的某段字符串称为 slice（字符串切片&#x2F;字符串片段）。上面提到的，文本字符串本身是动态长度的 UTF-8 编码序列，且拥有数据的所有权。当我们只需要借用字符串文本数据本身时，我们需要使用 <code>&amp;str</code> 类型，它包含指针（ptr &#x3D; 该 slice 第一个字符在内存中对应的地址）、长度（len &#x3D; 从第一个字符开始，一共多少个字符），slice 因为是借用关系，本身是不可变的。字符串本身是动态大小的类型，有了 slice 的借用类型之后，编译时就可以计算出对应字符串所占字节大小，这对 Rust 这种强静态编译语言是必需的。它有两种具体使用场景：</p>
<ol>
<li>普通文本字符串（string literal）：不可修改</li>
<li>作为某个 <code>String</code> 类型的切片字符串：不可修改</li>
</ol>
<p>可以看到，都是不可修改，所以当我们有要修改字符串的计划，我们就应该使用上面 <code>String</code> 类型，而不修改的话就选择 <code>&amp;str</code> 类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">str_and_string</span>() &#123;</span><br><span class="line">    <span class="comment">// 普通文本字符串 string literals</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">normal_str</span> = <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line">    <span class="comment">// 可操作的、拥有所有权的 String 类型字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutable_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(normal_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a string slice of String, 没有修改字符串的计划</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;mutable_string[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello = &#123;&#125;&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改字符串 &amp;mut 才能修改</span></span><br><span class="line">    <span class="title function_ invoke__">do_some_mutation</span>(&amp;<span class="keyword">mut</span> mutable_string);</span><br><span class="line">    <span class="comment">// 只需要借用字符串的值</span></span><br><span class="line">    <span class="title function_ invoke__">only_use_text</span>(&amp;mutable_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mutable_string = &#123;&#125;&quot;</span>, mutable_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_some_mutation</span>(input: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    input.<span class="title function_ invoke__">replace_range</span>(<span class="number">0</span>..<span class="number">1</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">    input.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;add this to the end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">only_use_text</span>(input: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;input[..=<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;greet = &#123;&#125;&quot;</span>, [hello, world].<span class="title function_ invoke__">concat</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>隐式类型转换 <code>String</code> -&gt; <code>&amp;str</code></p>
<p>当函数参数定义为 <code>&amp;str</code> 切片类型时，我们在传入的是完整切片时是可以直接传入 <code>String</code> 类型字符串的，相当于 <code>&amp;s[..]</code>，Rust 实现了自动解引用，在必要时会将 <code>&amp;String</code> 自动转换成 <code>&amp;str</code> 。这样使得，如果接受参数是字符串的引用，我们采用 <code>&amp;str</code> 作为入参，但能获得两种类型数据的兼容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> :<span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line"><span class="comment">// String 转换成 slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = s.<span class="title function_ invoke__">as_str</span>();</span><br></pre></td></tr></table></figure>

<p>注意：反过来是不行的，因为 <code>String</code> 类型 转 切片类型，没有转换成本，而从 切片类型 转 <code>String</code> 类型还需要为其重新申请内存，对性能是有损耗的，Rust 不会自动做这个行为。</p>
<h5 id="与其他类型的转换"><a href="#与其他类型的转换" class="headerlink" title="与其他类型的转换"></a>与其他类型的转换</h5><p><img src="/images/image-20241013075143718.png" alt="image-20241013075143718"></p>
<h5 id="元组-The-Tuple-Type"><a href="#元组-The-Tuple-Type" class="headerlink" title="元组 The Tuple Type"></a>元组 The Tuple Type</h5><p>混合类型 —— 多种类型的数值的集合，一旦定义了不能改变长度</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值(1)</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>); <span class="comment">// ✅ The value of y is: 6.4</span></span><br><span class="line"><span class="comment">// 取值(2)</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Values in tup: &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>); <span class="comment">// ✅ Values in tup: 500 6.4 1</span></span><br></pre></td></tr></table></figure>

<h5 id="数组-The-Array-Type"><a href="#数组-The-Array-Type" class="headerlink" title="数组 The Array Type"></a>数组 The Array Type</h5><p>数组的定义其实就是为分配一段连续的相同数据类型的内存块。</p>
<p><code>[T; N]</code> 表示 <code>N</code> 个值的数组，每个值的类型为 <code>T</code>。数组长度一经定义不可修改，所以编译时数组占用的内存大小就已是确定的了，不能追加或删除元素，但可以修改元素的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明类型和长度，后赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 定义后无法再修改大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的值，可以简化创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// 5 个 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转迭代器，得到 (index, value) 枚举对 list</span></span><br><span class="line">a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>()</span><br></pre></td></tr></table></figure>

<p>遍历方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知长度</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未知长度：迭代器</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的引用都是值的传递，即和原数组没有联系，原数组不受任何影响</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_arr</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = a;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a &#123;:?&#125;&quot;</span>, a); <span class="comment">// [0, 20]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b &#123;:?&#125;&quot;</span>, b); <span class="comment">// [10, 20]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1111 &#123;:?&#125;&quot;</span>, arr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 参数传递，是直接复制 arr 的值传入，和 arr 无关</span></span><br><span class="line">    <span class="title function_ invoke__">update</span>(arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;2222 &#123;:?&#125;&quot;</span>, arr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update</span>(<span class="keyword">mut</span> arr: [<span class="type">i32</span>; <span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            arr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;update &#123;:?&#125;&quot;</span>, arr); <span class="comment">// [0, 0, 0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="向量-The-Vec-Type"><a href="#向量-The-Vec-Type" class="headerlink" title="向量 The Vec Type"></a>向量 The Vec Type</h5><p>An array-like data structure，一种类数组数据结构，和数组的区别是它支持动态大小，即可以增加或删除元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      使用Vec和HashMap实现书籍库管理系统</span></span><br><span class="line"><span class="comment">      添加书籍，查询库存，更新库存，删除书籍</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">books</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="string">&quot;The Rust Programming Language&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Welcome to Rust&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Rust by Example&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BookSystem</span> &#123;</span><br><span class="line">        map: HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">BookSystem</span> &#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(books: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> BookSystem &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">book</span> <span class="keyword">in</span> books &#123;</span><br><span class="line">                map.<span class="title function_ invoke__">insert</span>(book.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BookSystem &#123; map &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加书籍</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.map.<span class="title function_ invoke__">insert</span>(name.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询库存</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">find</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.map.<span class="title function_ invoke__">get</span>(&amp;name.<span class="title function_ invoke__">to_string</span>()) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(num) =&gt; *num,</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="number">0</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新库存</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">update</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>, num: <span class="type">i32</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.map.<span class="title function_ invoke__">insert</span>(name.<span class="title function_ invoke__">to_string</span>(), num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除书籍</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">delete</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.map.<span class="title function_ invoke__">remove_entry</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">log</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; Current stock &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (k, v) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.map &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;[&#123;&#125;]: &#123;&#125;&quot;</span>, k, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sys</span> = BookSystem::<span class="title function_ invoke__">new</span>(books);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book_name</span> = <span class="string">&quot;Easy Rust&quot;</span>;</span><br><span class="line">    sys.<span class="title function_ invoke__">add</span>(book_name);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">    sys.<span class="title function_ invoke__">update</span>(book_name, <span class="number">3</span>);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The stock of [&#123;&#125;] is &#123;&#125;&quot;</span>, book_name, sys.<span class="title function_ invoke__">find</span>(book_name));</span><br><span class="line">    sys.<span class="title function_ invoke__">delete</span>(book_name);</span><br><span class="line">    sys.<span class="title function_ invoke__">log</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="切片-The-Slice-Type"><a href="#切片-The-Slice-Type" class="headerlink" title="切片 The Slice Type"></a>切片 The Slice Type</h5><p>表示 <code>String</code> 类型、<code>Array</code> 类型、<code>Vec</code> 类型 的局部数据，<code>&amp;T</code> 只引用值，<code>&amp;mut T</code> 可以修改原数据</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">切片常用函数</span><br><span class="line"><span class="bullet">-</span> len(): 取 slice 元素个数</span><br><span class="line"><span class="bullet">-</span> is<span class="emphasis">_empty(): 判断 slice 是否为空</span></span><br><span class="line"><span class="emphasis">- contains(): 判断是否包含某个元素</span></span><br><span class="line"><span class="emphasis">- repeat(): 重复 slice 指定次数</span></span><br><span class="line"><span class="emphasis">- reverse(): 反转 slice</span></span><br><span class="line"><span class="emphasis">- join(): 将各元素压平（flatten）并通过指定的分隔符连接起来</span></span><br><span class="line"><span class="emphasis">- swap(): 交换两个索引处的元素，如 s.swap(1, 3)</span></span><br><span class="line"><span class="emphasis">- windows(): 以指定大小的窗口进行滚动迭代</span></span><br><span class="line"><span class="emphasis">- start_</span>with(): 判断 slice 是否以某个 slice 开头</span><br></pre></td></tr></table></figure>

<h5 id="自定义类型-Custom-Types"><a href="#自定义类型-Custom-Types" class="headerlink" title="自定义类型 Custom Types"></a>自定义类型 Custom Types</h5><p>Rust 自定义数据类型主要通过 <code>struct</code> 和 <code>enum</code> 关键字形成</p>
<ul>
<li><code>struct</code>: 定义一个结构体型数据</li>
<li><code>enum</code>: 定义一个枚举型数据</li>
</ul>
<h6 id="结构体-Structures"><a href="#结构体-Structures" class="headerlink" title="结构体 Structures"></a>结构体 Structures</h6><p>基础用法，结构体可以定义 n 多个字段</p>
<ul>
<li>结构体变量和一般变量一样，默认也是不可变的（immutable），<code>let mut T = struct XXX</code> 定义可变的（mutable）结构体变量</li>
<li>可以没有任何字段名，但不能没有字段类型，这种结构体长的像元组，所以被被称为元祖结构体（tuple struct），例如：<code>struct Point(i32, i32, i32)</code> 表示一个点的坐标 <code>x,y,z</code></li>
<li>可以不包含任何字段，即没有类型也没有名称，被称为单元结构体</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">me</span> = Person &#123; name: <span class="string">&quot;Marnie&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A unit struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A tuple struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>(<span class="type">i32</span>, <span class="type">f32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Pair</span>(<span class="number">8</span>, <span class="number">0.2</span>);</span><br><span class="line"><span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct with two fields</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0.5</span>, y: <span class="number">1.2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Structs can be reused as fields of another struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// A rectangle can be specified by where the top left and bottom right</span></span><br><span class="line">    <span class="comment">// corners are in space.</span></span><br><span class="line">    top_left: Point,</span><br><span class="line">    bottom_right: Point,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point_top_left</span> = Point &#123; x: <span class="number">0.5</span>, y: <span class="number">1.2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point_bottom_right</span> = Point &#123; x: <span class="number">1.8</span>, y: <span class="number">0.2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123; top_left: point_top_left, bottom_right: point_bottom_right &#125;;</span><br></pre></td></tr></table></figure>

<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>结构体更新语法：我们可以用 <code>..structA</code> 给 <code>structB</code> 进行更新，在 <code>structB</code> 中没有显示声明的字段，都会从 <code>structA</code> 中取 。</p>
<p>但是注意了📢，在 Rust 中严格管控着数据所有权（ownership），所以当针对没有 copy 特性的字段被用来赋值之后，该字段的数据所有权即会发生转移。只要有一个字段发生了所有权变化，那么整个结构体就已经是不完整的了，该结构体本身就不能再被转移，即无法整个结构体直接使用。</p>
<p>没有 copy 特性（trait）指的就是那些存在 heap 上的数据，在 stack-side 存储的是其内存块的 pointer，赋值操作即原指针失效，内存地址转移到新指针上。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">     active: <span class="literal">true</span>,</span><br><span class="line">     username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;example1&quot;</span>),</span><br><span class="line">     email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;example1@examples.com&quot;</span>),</span><br><span class="line">     sign_in_count: <span class="number">1</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">     email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;example2@examples.com&quot;</span>),</span><br><span class="line">     ..user1</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>结构体可以包含行为，即带有方法（方法和函数是有区别的）的结构体</p>
<h6 id="枚举型-Enum"><a href="#枚举型-Enum" class="headerlink" title="枚举型 Enum"></a>枚举型 Enum</h6><p>结构体通常是描述带有不同字段的某个类型，而枚举型指的是某个更上层的类型下会包含多个不同类型，比如动物类型包含猫猫、狗狗、兔子、猪等等</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  Dog,</span><br><span class="line">  Cat,</span><br><span class="line">  Rabbit,</span><br><span class="line">  Pig,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a>函数 Functions</h3><h4 id="语句-Statements"><a href="#语句-Statements" class="headerlink" title="语句 Statements"></a>语句 Statements</h4><p>表示一个要执行的操作，没有返回值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="comment">// ❌ 首先 let y = 1; 是个语句，没有返回值，且（）中加表达式只能在 if、while 条件判断下使用</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等同于 let x = 1; let y = 1;</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制-Control-Flow"><a href="#流程控制-Control-Flow" class="headerlink" title="流程控制 Control Flow"></a>流程控制 Control Flow</h3><h4 id="条件控制-if"><a href="#条件控制-if" class="headerlink" title="条件控制 if"></a>条件控制 <code>if</code></h4><p><code>if</code> 表达式的条件（condition）必须是 <code>bool</code> 类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ error[E0308]: mismatched types, expected `bool`, found integer&quot;</span></span><br><span class="line"><span class="keyword">if</span> number &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Never print: expected `bool`, found integer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if or else</code> 表达式后紧跟的代码块被称为 arms，和 <code>match</code> 表达式的 arms 一致</p>
<p><code>if</code> 表达式的代码块最后一行若是表达式，即为当前块的返回值</p>
<p>若是多个 <code>if...else if</code> 每个代码块的返回值类型需要一致</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">if_else_expressions</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">55</span>;</span><br><span class="line">    <span class="keyword">const</span> NOT_MATCHED_MESSAGE: &amp;<span class="type">str</span> = <span class="string">&quot;Not Matched&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="string">&quot;Divide by 4&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="string">&quot;Divide by 3&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="string">&quot;Divide by 2&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NOT_MATCHED_MESSAGE</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> message != NOT_MATCHED_MESSAGE &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>todo()!</code> 表示延迟实现当前代码块，和占位符概念类似，即可以跳过类型检查</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="title function_ invoke__">todo</span>()!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环-Loop"><a href="#循环-Loop" class="headerlink" title="循环 Loop"></a>循环 Loop</h4><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a><code>loop</code></h4><p><code>loop</code> 加大括号声明循环（代码块可以有返回值），<code>continue</code> 跳出本次循环，<code>break</code> 跳出并终止整个循环，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">loop_expressions</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">10</span>; <span class="comment">// 终止循环，并有返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套循环，用 <code>单引号 + label</code> 的格式命名，<code>break LOOP_NAME</code> 跳出对应循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">nested_loops</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, count);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;&#125;&quot;</span>, remaining);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 结束并跳出当前循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>; <span class="comment">// 结束并跳出 &#x27;counting_up 循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while"><a href="#while" class="headerlink" title="while"></a><code>while</code></h4><p>如果需要判断某些条件的循环，可以使用 <code>while</code> 更方便</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">while_case</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> count &lt; <span class="number">12</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h4><p><code>for loop</code> 遍历数组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loop in array</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">for_loop</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;i=&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1..=5 快速创建一个1-5的</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;n=&#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// (1..=5).rev() 快速创建一个5-1倒序的数组</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> (<span class="number">1</span>..=<span class="number">5</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;n=&#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop in vector</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">vector_case</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示并非所有权转移，&amp; 表示借用，借用是只读</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vv</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        <span class="comment">// vv 是对 v 中的某个 vector 的引用，</span></span><br><span class="line">        <span class="comment">// 引用的本质是一个指针，指针不能直接和值进行比较，</span></span><br><span class="line">        <span class="comment">// 需要加 *号 解引用，解引用就表示该引用变量的值</span></span><br><span class="line">        <span class="keyword">if</span> *vv == <span class="number">1</span> &#123;</span><br><span class="line">            *vv = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;v=&#123;&#125;&quot;</span>, vv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="所有权-Ownership"><a href="#所有权-Ownership" class="headerlink" title="所有权 Ownership"></a>所有权 Ownership</h3><p>所有权是控制一个 Rust 程序如何管理内存的一套规则。所有程序都要有管理它们在运行时使用计算机内存的方式。</p>
<h4 id="内存管理方式-Memory-Management"><a href="#内存管理方式-Memory-Management" class="headerlink" title="内存管理方式 Memory Management"></a>内存管理方式 Memory Management</h4><p>常见的内存管理方式：</p>
<ul>
<li>垃圾回收（Garbage Collection）：如 JavaScript、Java 这种动态语言，语言层面设计了一套内存回收机制，垃圾回收器会持续追踪内存的分配并定期找到不再被使用的内存进行释放回收，让开发者无需去关心内存的分配和回收</li>
<li>手动管理（Manual Management）：如 C、C++ 这种静态语言，需要手动调用分配和释放内存的方法进行操作，这让开发者需要对内存的分配及释放负责，忘记释放会导致内存浪费，太早释放又会导致获得无效的变量</li>
</ul>
<p>第三种 —— Rust 使用的内存管理方式：所有权系统（Ownership System）</p>
<ul>
<li>所有者（ower）指的是这块内存（memory）是属于谁的，包括访问和修改的能力</li>
<li>每个值都有一个所有者，任何时候都只能有一个有效所有者</li>
<li>当所有者离开作用域（scope），值会被丢弃（drop）</li>
<li>遵循所有权系统规则，编译器在编译时通过静态分析管理内存安全，违背规则的程序不会通过编译</li>
<li>通过借用（borrowing，即引用）机制来共享数据</li>
</ul>
<h4 id="🎯-TODO：内存分配方式-Memory-Allocation"><a href="#🎯-TODO：内存分配方式-Memory-Allocation" class="headerlink" title="🎯 TODO：内存分配方式 Memory Allocation"></a>🎯 TODO：内存分配方式 Memory Allocation</h4><ul>
<li>栈（Stack）：连续的内存空间，从低地址到高地址逐步分配，简单数据类型会被直接存储在栈上，便于操作</li>
<li>堆（Heap）：非连续内存空间，申请多少大小空间就一次性分配多少，会通过一个指针指向这一块内存空间，复杂数据类型的值会在堆上开辟对应的空间存放，而栈上对应的这个变量存的是与这块内存相关的指针信息，即内存地址（adress）、大小（Capacity）、长度（Length）</li>
<li>Static：blahblahblah…</li>
</ul>
<h4 id="转移-或-复制-Move-or-Copy"><a href="#转移-或-复制-Move-or-Copy" class="headerlink" title="转移 或 复制 Move or Copy"></a>转移 或 复制 Move or Copy</h4><p>基于不同的内存分配方式，针对数据和变量之间的赋值操作，在 Rust 中也会有两种表现情况：</p>
<ul>
<li>简单数据类型：一般是固定大小的数据，值存放在栈上，赋值是对值的拷贝（copy）</li>
<li>复杂数据类型：一般为非固定大小数据，值被存放在堆上，该内存一旦分配，赋值的操作默认被看做为转移（move），即将该内存的所有权转移给某个变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a; <span class="comment">// directly copy 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// move</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a; <span class="comment">// move the ownership of &quot;Hello&quot; from a to b</span></span><br><span class="line"><span class="comment">// current, a is considered as transferred, which means it&#x27;s no longer needed</span></span><br></pre></td></tr></table></figure>

<p>其实可以简单理解，转移（move）是所有权（ownership）系统实现 “内存所有者只能有一个” 的一种规则机制，这个机制防止出现数据竞争的可能 —— 多个线程对统一资源进行访问和修改，从而导致程序结果与期望不符。本身具有所有权的变量本质是存在栈上的某个指针类型变量，它的作用是为了指向堆中的某块内存，所以一经转移，相当于指针不再指向这块内存，这个变量就不再有效了，即不可以再被访问。</p>
<h4 id="所有权和生命周期（Lifetimes）"><a href="#所有权和生命周期（Lifetimes）" class="headerlink" title="所有权和生命周期（Lifetimes）"></a>所有权和生命周期（Lifetimes）</h4><p>所有权是指某块内存的所有者，所有者是某个变量，而变量的生命周期和所在作用域相关，在某个作用域下定义的变量只能在该作用域下使用。所有权也有着相应的限制，变量在某个作用域（scope）内被分配到对应数据的内存，在离开作用域后，变量会变得无效，它会交还对某个数据内存的所有权，则该“无主”的数据内存会被视为不再需要的，会触发自动释放内存的机制，也就是回收内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// s is valid from this point</span></span><br><span class="line">  <span class="comment">// s is the owner of the string &quot;Hello&quot;</span></span><br><span class="line">&#125; <span class="comment">// this scope is over now, s and string &quot;Hello&quot; are not valid</span></span><br><span class="line"><span class="comment">// the data is not valid means it is no longer needed, which will trigger the step of freeing memory</span></span><br></pre></td></tr></table></figure>

<p>当变量被传入某个函数，也是发生了转移操作，意味着数据的所有权被传递给了函数，函数外已经没有权利访问和修改该变量所指的数据。如下例子：</p>
<p><img src="/images/image-20241005203754332.png" alt="image-20241005203754332"></p>
<p>第一步，<code>s</code> 拥有了 <code>string &quot;Hello&quot;</code> 的所有权</p>
<p>第二步，将 <code>string &quot;Hello&quot;</code> 的所有权转移给了 <code>carry_params</code> 函数</p>
<p>而 <code>carry_params</code> 没有对参数 <code>s</code> 做任何处理，那么在函数执行完毕后，离开作用域，入参 <code>s</code> 对应也不再有效，对应占用的数据内存会被释放</p>
<p>第三步，我们再打印 <code>s</code> 就会得到值已被转移了，即无权访问的编译错误提示</p>
<h4 id="拥有所有权的作用"><a href="#拥有所有权的作用" class="headerlink" title="拥有所有权的作用"></a>拥有所有权的作用</h4><p>所有权是指对某块内存的所有，即拥有读写这块内存的权力，当我们需要修改某个数据时，我们就需要拥有其所有权，才能有修改的能力。而当我们只需要读，而不需要写，那就不必拥有或者转移其所有权。可以看到，有了所有权规则的加持，代码变得更加安全但也因此增加了书写代码的难度。</p>
<p>上面提到如果我们不需要获得某个数据的所有权，只是想要访问值，可以用另一个概念 —— 借用（borrow）。</p>
<h4 id="借用-Borrow"><a href="#借用-Borrow" class="headerlink" title="借用 Borrow"></a>借用 Borrow</h4><p>当我们不需要数据的所有权时，我们使用借用来访问数据的值，借用分为两种：</p>
<ul>
<li>borrow：不可变的借用，我只是把数据借给你用 <code>&amp;T</code></li>
<li>borrow mutably：可变的借用，我不仅把数据借给你用，且给你修改它的权限 <code>&amp;mut T</code>，这种借用也可以被叫做引用（reference）</li>
</ul>
<p>其实可以理解为，<code>&amp;</code> 给了读数据的权力，<code>&amp;mut</code>  在读的基础上给了写的权力，但数据（也就是这块内存）的拥有者并没有变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">str_and_string</span>() &#123;</span><br><span class="line">    <span class="comment">// 普通文本字符串 string literals</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">normal_str</span> = <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line">    <span class="comment">// 可操作的、拥有所有权的 String 类型字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutable_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(normal_str);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// a string slice of String,</span></span><br><span class="line">    <span class="comment">// 借用（引用） &quot;hello, &quot;，没有修改字符串的需求</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;mutable_string[..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;slice = &#123;&#125;&quot;</span>, slice);</span><br><span class="line">    <span class="comment">// 借用对象 和 被借用对象 都是指向同一块内存，所以相等</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice, mutable_string);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1️⃣ 默认借用，只需要借用字符串的值，不涉及所有权</span></span><br><span class="line">    <span class="title function_ invoke__">only_use_text</span>(&amp;mutable_string);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2️⃣ 可变的借用，不仅可以访问值，还给了修改值的权力</span></span><br><span class="line">   <span class="comment">// 需要声明 &amp;mut 才能修改字符串</span></span><br><span class="line">    <span class="title function_ invoke__">do_some_mutation</span>(&amp;<span class="keyword">mut</span> mutable_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mutable_string = &#123;&#125;&quot;</span>, mutable_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_some_mutation</span>(input: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    input.<span class="title function_ invoke__">replace_range</span>(<span class="number">0</span>..<span class="number">1</span>, <span class="string">&quot;H&quot;</span>);</span><br><span class="line">    input.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;add this to the end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">only_use_text</span>(input: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;input[..=<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;greet = &#123;&#125;&quot;</span>, [hello, world].<span class="title function_ invoke__">concat</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="🎯-TODO：生命周期-Lifetimes"><a href="#🎯-TODO：生命周期-Lifetimes" class="headerlink" title="🎯 TODO：生命周期 Lifetimes"></a>🎯 TODO：生命周期 Lifetimes</h3><h5 id="NLL-——-Non-Lexical-Lifetimes"><a href="#NLL-——-Non-Lexical-Lifetimes" class="headerlink" title="NLL —— Non-Lexical Lifetimes"></a>NLL —— Non-Lexical Lifetimes</h5><h5 id="Dangling-Referencing-悬垂引用"><a href="#Dangling-Referencing-悬垂引用" class="headerlink" title="Dangling Referencing 悬垂引用"></a>Dangling Referencing 悬垂引用</h5><p>指的是一个变量是有效状态的时间，即可以被使用的时长，通常也被叫做存活（live）时间。</p>
<p>生命周期是 Rust 用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围，确保在引用仍然有效的时候使用它们。</p>
<p>在 Rust 中，一个变量的存活时间与其作用域（scope）和是否还存在被使用（引用 references）有关。</p>
<ul>
<li><p>作用域规则决定了一个变量能否被访问，在某个作用域下定义的变量也只在这个作用域内有效，即离开作用域后无法被访问，会自动被销毁。</p>
</li>
<li><p>当编译器检查到一个变量不再存在任何被引用被借用关系后，该变量也会被自动销毁。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> :<span class="type">i32</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 存在被使用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x); <span class="comment">// after this line, x has no more references, will be automatically destroyed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> :<span class="type">i32</span> = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h4 id="借用规则-Borrow-Rules"><a href="#借用规则-Borrow-Rules" class="headerlink" title="借用规则 Borrow Rules"></a>借用规则 Borrow Rules</h4><ul>
<li>一个变量只能存在一个可变引用或者多个不可变引用，不能同时存在可变和不可变引用</li>
</ul>
<h4 id="借用检查器-Borrow-Checker"><a href="#借用检查器-Borrow-Checker" class="headerlink" title="借用检查器 Borrow Checker"></a>借用检查器 Borrow Checker</h4><p>前面说了，借用是用于不关心所有权的场景下的，那没有所有权就意味着我需要依赖被我借用的那个变量，当它不合法时、无效时，那我的借用行为也是不可能通过的。Borrow Checker 便是在编译时，检查借用是否合法，即被借用的变量是否还在有效的生命周期内。结合前面提到的所有权的生命周期，来看下截图上的例子：</p>
<p><img src="/images/image-20241010163617345.png" alt="image-20241010163617345"></p>
<p>可以看到报错部分说的是被借用值 x 存活的不够长，重点看下黄色框内，模拟画的作用域结构图。</p>
<ul>
<li><code>r</code> 在 a 作用域中创建，即它存活在作用域 a 存活的期间，即 foo 函数执行期间</li>
<li><code>x</code> 在 b 作用域中创建，即它存活在作用域 b 存活的期间，作用域 b 是个 block 作用域，在它执行完成后内部变量都会自动释放，即 <code>x</code> 在作用域 b 外无效</li>
</ul>
<p>因为 <code>r</code> 是个借用类型，Borrow Checker 会检查被借用变量是否是有效的，当发现被借用变量的生命周期小于借用变量的生命周期，即 <code>x</code> 的生命周期小于 <code>r</code> 的生命周期，这是不合法的 —— 报错。所以如果是存在借用关系的两个变量，那么被借用变量的存活时间一定要比借用变量存活的时间更长，存活时间更长可以归纳为两种情况：</p>
<ul>
<li>相同作用域范围下，被借用变量定义早于借用变量</li>
<li>借用变量的作用域层级深于被借用变量（越深销毁越早）</li>
</ul>
<h5 id="📸-TODO-手动管理可能会遇到的问题"><a href="#📸-TODO-手动管理可能会遇到的问题" class="headerlink" title="📸 TODO 手动管理可能会遇到的问题"></a>📸 TODO 手动管理可能会遇到的问题</h5><p>内存泄露</p>
<p>悬空指针</p>
<p>缓冲区溢出</p>
<h2 id="泛型（Generics）和特质（Traits）"><a href="#泛型（Generics）和特质（Traits）" class="headerlink" title="泛型（Generics）和特质（Traits）"></a>泛型（Generics）和特质（Traits）</h2><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `unwrap()`: 有值的时候会取值，没值的时候会 `panic`</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = s.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p1);</span><br></pre></td></tr></table></figure>

<h2 id="返回值与错误处理"><a href="#返回值与错误处理" class="headerlink" title="返回值与错误处理"></a>返回值与错误处理</h2><h3 id="可恢复的错误-Result"><a href="#可恢复的错误-Result" class="headerlink" title="可恢复的错误 Result&lt;T, E&gt;"></a>可恢复的错误 <code>Result&lt;T, E&gt;</code></h3><p>从系统全局角度来看是可以接受的错误，这些错误只会影响某个用户自身的操作进程，一般是逻辑层面上的错误（业务逻辑、操作逻辑），不会对系统的全局稳定性产生影响。</p>
<h4 id="使用-Result-返回值"><a href="#使用-Result-返回值" class="headerlink" title="使用 Result 返回值"></a>使用 Result 返回值</h4><h3 id="不可恢复的错误-panic"><a href="#不可恢复的错误-panic" class="headerlink" title="不可恢复的错误 panic!"></a>不可恢复的错误 <code>panic!</code></h3><p>全局性或者系统性的错误，列入数组越界访问、影响启动流程的错误等等，这些错误是影响系统流程的。</p>
<h4 id="主动触发-panic"><a href="#主动触发-panic" class="headerlink" title="主动触发 panic"></a>主动触发 panic</h4><p>Rust 提供了 <code>panic!</code> 宏，当调用执行该宏时，程序会打印出一个错误信息，展开报错点前面的函数调用堆栈，最后退出程序。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="backtrace-栈展开"><a href="#backtrace-栈展开" class="headerlink" title="backtrace 栈展开"></a>backtrace 栈展开</h4><p>默认程序执行调用栈输出是开启 <code>--debug</code> 的时候才会展示，可以通过 <code>RUST_BACKTRACE=1 cargo run</code> 来手动开启调用栈回溯。</p>
<p>栈展开也称栈回溯，包含了函数调用的顺序，按照逆序排列：最近调用的函数在列表最上方。</p>
<h4 id="unwrap-方法"><a href="#unwrap-方法" class="headerlink" title="unwrap 方法"></a><code>unwrap</code> 方法</h4><ul>
<li><code>Option</code> : 有值的时候会取值，没值的时候会调用 <code>panic!</code></li>
<li><code>Result</code> : <code>Ok</code> 会返回 <code>Ok</code> 中的值，<code>Err</code> 会为我们调用 <code>panic!</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">first</span>(&amp;arr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is &#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<h4 id="expect-方法"><a href="#expect-方法" class="headerlink" title="expect 方法"></a><code>expect</code> 方法</h4><p>用于设置预期的 panic 错误文案</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, file);</span><br></pre></td></tr></table></figure>

<h4 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h4><p><code>unwrap</code> 方法在遇到错误情况下都会直接调用 <code>panic!</code> 从而会直接终止程序的进行，但很多情况下我们遇到的都是预期内的错误情况，并不需要终止，只需要将错误向上传播，这时我们就不用使用 <code>unwrap</code> 方法。取而代之，通常使用 <code>?</code> 链式调用传播错误，它的功能是问号前的表达式执行结果成功则继续向后执行，若结果失败或者说错误，则截停执行逻辑到当前表达式为止并将错误返回，此时如果前一个表达式设置了错误 callback 等类似的处理，就能触发相应的逻辑。</p>
<h5 id="Option-和-Result-的互转"><a href="#Option-和-Result-的互转" class="headerlink" title="Option 和 Result 的互转"></a>Option 和 Result 的互转</h5><p>Result 有两个结果 <code>Ok</code> 和 <code>Err</code>，Option 包含 <code>Some</code> 和 <code>None</code></p>
<ul>
<li><p>Result 转 Option，转换即将 <code>ok</code> 和 <code>err</code> 都转为 <code>Some</code></p>
<ul>
<li><p><code>err(): Err -&gt; Some</code></p>
</li>
<li><p><code>ok(): Ok -&gt; Some</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">err</span>();</span><br><span class="line"><span class="keyword">if</span> f.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;no file&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">ok</span>();</span><br><span class="line"><span class="keyword">if</span> f.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;no file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Option 转 Result</p>
<ul>
<li><code>ok_or()</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marniewu.github.io/2024/10/23/rust-basic/" data-id="cm3buz5tz00014l1670eyaomm" data-title="Rust Basic" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/01/first-project/">First Project</a>
          </li>
        
          <li>
            <a href="/2024/10/24/smart-pointers/">Smart Pointers</a>
          </li>
        
          <li>
            <a href="/2024/10/23/rust-basic/">Rust Basic</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Marnie Wu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>